
FREERTOS_UC3_EXAMPLE1.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         000024b8  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80004600  80004600  00004a00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80004800  80004800  00004c00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000150  80004818  80004818  00004c18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  80004968  00005008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  80004970  00005010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  80004978  00005018  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  8000497c  0000501c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000524  0000001c  8000497c  0000501c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .balign       00000000  00000540  80004ea0  00005540  2**0
                  ALLOC
 14 .bss          00000288  00000540  00000540  00000000  2**2
                  ALLOC
 15 .heap         0000e838  000007c8  000007c8  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  00005540  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 00000a08  00000000  00000000  00005570  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 00001599  00000000  00000000  00005f78  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   00011eb6  00000000  00000000  00007511  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 00002f5a  00000000  00000000  000193c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   0000a506  00000000  00000000  0001c321  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  00001740  00000000  00000000  00026828  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    000036d8  00000000  00000000  00027f68  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    00003810  00000000  00000000  0002b640  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 00d21597  00000000  00000000  0002ee50  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 000009d0  00000000  00000000  00d503e7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 4c       	rcall	800020c4 <frame_dummy>
8000201e:	e0 a0 12 57 	rcall	800044cc <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb d6 cc 	sub	r11,pc,-10548
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 40 	mov	r10,1344
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 07 c8 	mov	r10,1992
8000204e:	e0 6c 05 40 	mov	r12,1344
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 05 46 	rcall	80002ae8 <_init_startup>
80002060:	fe cc d8 60 	sub	r12,pc,-10144
80002064:	e0 a0 0d 34 	rcall	80003acc <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 10 3d 	rcall	800040e8 <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	e0 a0 02 3f 	rcall	800024fc <main>
80002082:	e0 a0 0d 2d 	rcall	80003adc <exit>
80002086:	d7 03       	nop

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	e0 68 05 40 	mov	r8,1344
8000208e:	11 89       	ld.ub	r9,r8[0x0]
80002090:	30 08       	mov	r8,0
80002092:	f0 09 18 00 	cp.b	r9,r8
80002096:	c1 61       	brne	800020c2 <__do_global_dtors_aux+0x3a>
80002098:	31 08       	mov	r8,16
8000209a:	31 46       	mov	r6,20
8000209c:	10 95       	mov	r5,r8
8000209e:	10 16       	sub	r6,r8
800020a0:	e0 67 05 44 	mov	r7,1348
800020a4:	a3 46       	asr	r6,0x2
800020a6:	20 16       	sub	r6,1
800020a8:	c0 68       	rjmp	800020b4 <__do_global_dtors_aux+0x2c>
800020aa:	2f f8       	sub	r8,-1
800020ac:	8f 08       	st.w	r7[0x0],r8
800020ae:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b2:	5d 18       	icall	r8
800020b4:	6e 08       	ld.w	r8,r7[0x0]
800020b6:	0c 38       	cp.w	r8,r6
800020b8:	cf 93       	brcs	800020aa <__do_global_dtors_aux+0x22>
800020ba:	30 19       	mov	r9,1
800020bc:	e0 68 05 40 	mov	r8,1344
800020c0:	b0 89       	st.b	r8[0x0],r9
800020c2:	d8 22       	popm	r4-r7,pc

800020c4 <frame_dummy>:
800020c4:	d4 01       	pushm	lr
800020c6:	31 8c       	mov	r12,24
800020c8:	78 08       	ld.w	r8,r12[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 50       	breq	800020d6 <frame_dummy+0x12>
800020ce:	48 38       	lddpc	r8,800020d8 <frame_dummy+0x14>
800020d0:	58 08       	cp.w	r8,0
800020d2:	c0 20       	breq	800020d6 <frame_dummy+0x12>
800020d4:	5d 18       	icall	r8
800020d6:	d8 02       	popm	pc
800020d8:	00 00       	add	r0,r0
	...

800020dc <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800020dc:	f8 08 16 05 	lsr	r8,r12,0x5
800020e0:	a9 68       	lsl	r8,0x8
800020e2:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800020e6:	58 1b       	cp.w	r11,1
800020e8:	c0 d0       	breq	80002102 <gpio_enable_module_pin+0x26>
800020ea:	c0 63       	brcs	800020f6 <gpio_enable_module_pin+0x1a>
800020ec:	58 2b       	cp.w	r11,2
800020ee:	c1 00       	breq	8000210e <gpio_enable_module_pin+0x32>
800020f0:	58 3b       	cp.w	r11,3
800020f2:	c1 40       	breq	8000211a <gpio_enable_module_pin+0x3e>
800020f4:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800020f6:	30 19       	mov	r9,1
800020f8:	f2 0c 09 49 	lsl	r9,r9,r12
800020fc:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800020fe:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002100:	c1 28       	rjmp	80002124 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002102:	30 19       	mov	r9,1
80002104:	f2 0c 09 49 	lsl	r9,r9,r12
80002108:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000210a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000210c:	c0 c8       	rjmp	80002124 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000210e:	30 19       	mov	r9,1
80002110:	f2 0c 09 49 	lsl	r9,r9,r12
80002114:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002116:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002118:	c0 68       	rjmp	80002124 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000211a:	30 19       	mov	r9,1
8000211c:	f2 0c 09 49 	lsl	r9,r9,r12
80002120:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002122:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80002124:	30 19       	mov	r9,1
80002126:	f2 0c 09 4c 	lsl	r12,r9,r12
8000212a:	91 2c       	st.w	r8[0x8],r12
8000212c:	5e fd       	retal	0
8000212e:	d7 03       	nop

80002130 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002130:	d4 21       	pushm	r4-r7,lr
80002132:	18 97       	mov	r7,r12
80002134:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002136:	58 0b       	cp.w	r11,0
80002138:	c0 31       	brne	8000213e <gpio_enable_module+0xe>
8000213a:	30 05       	mov	r5,0
8000213c:	c0 d8       	rjmp	80002156 <gpio_enable_module+0x26>
8000213e:	30 06       	mov	r6,0
80002140:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80002142:	6e 1b       	ld.w	r11,r7[0x4]
80002144:	6e 0c       	ld.w	r12,r7[0x0]
80002146:	f0 1f 00 06 	mcall	8000215c <gpio_enable_module+0x2c>
8000214a:	18 45       	or	r5,r12
		gpiomap++;
8000214c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000214e:	2f f6       	sub	r6,-1
80002150:	0c 34       	cp.w	r4,r6
80002152:	fe 9b ff f8 	brhi	80002142 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80002156:	0a 9c       	mov	r12,r5
80002158:	d8 22       	popm	r4-r7,pc
8000215a:	00 00       	add	r0,r0
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	20 dc       	sub	r12,13

80002160 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80002160:	c0 08       	rjmp	80002160 <_unhandled_interrupt>
80002162:	d7 03       	nop

80002164 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002164:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80002168:	49 99       	lddpc	r9,800021cc <INTC_register_interrupt+0x68>
8000216a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000216e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80002172:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80002174:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80002178:	58 0a       	cp.w	r10,0
8000217a:	c0 91       	brne	8000218c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000217c:	49 59       	lddpc	r9,800021d0 <INTC_register_interrupt+0x6c>
8000217e:	49 6a       	lddpc	r10,800021d4 <INTC_register_interrupt+0x70>
80002180:	12 1a       	sub	r10,r9
80002182:	fe 79 08 00 	mov	r9,-63488
80002186:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000218a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
8000218c:	58 1a       	cp.w	r10,1
8000218e:	c0 a1       	brne	800021a2 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002190:	49 09       	lddpc	r9,800021d0 <INTC_register_interrupt+0x6c>
80002192:	49 2a       	lddpc	r10,800021d8 <INTC_register_interrupt+0x74>
80002194:	12 1a       	sub	r10,r9
80002196:	bf aa       	sbr	r10,0x1e
80002198:	fe 79 08 00 	mov	r9,-63488
8000219c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800021a0:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800021a2:	58 2a       	cp.w	r10,2
800021a4:	c0 a1       	brne	800021b8 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800021a6:	48 b9       	lddpc	r9,800021d0 <INTC_register_interrupt+0x6c>
800021a8:	48 da       	lddpc	r10,800021dc <INTC_register_interrupt+0x78>
800021aa:	12 1a       	sub	r10,r9
800021ac:	bf ba       	sbr	r10,0x1f
800021ae:	fe 79 08 00 	mov	r9,-63488
800021b2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800021b6:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800021b8:	48 69       	lddpc	r9,800021d0 <INTC_register_interrupt+0x6c>
800021ba:	48 aa       	lddpc	r10,800021e0 <INTC_register_interrupt+0x7c>
800021bc:	12 1a       	sub	r10,r9
800021be:	ea 1a c0 00 	orh	r10,0xc000
800021c2:	fe 79 08 00 	mov	r9,-63488
800021c6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800021ca:	5e fc       	retal	r12
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	48 18       	lddpc	r8,800021d0 <INTC_register_interrupt+0x6c>
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	46 00       	lddsp	r0,sp[0x180]
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	47 04       	lddsp	r4,sp[0x1c0]
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	47 12       	lddsp	r2,sp[0x1c4]
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	47 20       	lddsp	r0,sp[0x1c8]
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	47 2e       	lddsp	lr,sp[0x1c8]

800021e4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800021e4:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800021e6:	49 18       	lddpc	r8,80002228 <INTC_init_interrupts+0x44>
800021e8:	e3 b8 00 01 	mtsr	0x4,r8
800021ec:	49 0e       	lddpc	lr,8000222c <INTC_init_interrupts+0x48>
800021ee:	30 07       	mov	r7,0
800021f0:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800021f2:	49 0c       	lddpc	r12,80002230 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800021f4:	49 05       	lddpc	r5,80002234 <INTC_init_interrupts+0x50>
800021f6:	10 15       	sub	r5,r8
800021f8:	fe 76 08 00 	mov	r6,-63488
800021fc:	c1 08       	rjmp	8000221c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800021fe:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80002200:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002202:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002204:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80002208:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000220a:	10 3a       	cp.w	r10,r8
8000220c:	fe 9b ff fc 	brhi	80002204 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002210:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002214:	2f f7       	sub	r7,-1
80002216:	2f 8e       	sub	lr,-8
80002218:	59 47       	cp.w	r7,20
8000221a:	c0 50       	breq	80002224 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000221c:	7c 08       	ld.w	r8,lr[0x0]
8000221e:	58 08       	cp.w	r8,0
80002220:	ce f1       	brne	800021fe <INTC_init_interrupts+0x1a>
80002222:	cf 7b       	rjmp	80002210 <INTC_init_interrupts+0x2c>
80002224:	d8 22       	popm	r4-r7,pc
80002226:	00 00       	add	r0,r0
80002228:	80 00       	ld.sh	r0,r0[0x0]
8000222a:	46 00       	lddsp	r0,sp[0x180]
8000222c:	80 00       	ld.sh	r0,r0[0x0]
8000222e:	48 18       	lddpc	r8,80002230 <INTC_init_interrupts+0x4c>
80002230:	80 00       	ld.sh	r0,r0[0x0]
80002232:	21 60       	sub	r0,22
80002234:	80 00       	ld.sh	r0,r0[0x0]
80002236:	47 04       	lddsp	r4,sp[0x1c0]

80002238 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002238:	fe 78 08 00 	mov	r8,-63488
8000223c:	e0 69 00 83 	mov	r9,131
80002240:	f2 0c 01 0c 	sub	r12,r9,r12
80002244:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002248:	f2 ca ff c0 	sub	r10,r9,-64
8000224c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002250:	58 08       	cp.w	r8,0
80002252:	c0 21       	brne	80002256 <_get_interrupt_handler+0x1e>
80002254:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
80002256:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000225a:	48 5a       	lddpc	r10,8000226c <_get_interrupt_handler+0x34>
8000225c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80002260:	f0 08 11 1f 	rsub	r8,r8,31
80002264:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002266:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000226a:	5e fc       	retal	r12
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	48 18       	lddpc	r8,80002270 <pm_set_osc0_mode>

80002270 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002270:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80002272:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002276:	99 a8       	st.w	r12[0x28],r8
}
80002278:	5e fc       	retal	r12
8000227a:	d7 03       	nop

8000227c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
8000227c:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000227e:	ec 5b bb 9f 	cp.w	r11,899999
80002282:	e0 8b 00 04 	brhi	8000228a <pm_enable_osc0_crystal+0xe>
80002286:	30 4b       	mov	r11,4
80002288:	c1 38       	rjmp	800022ae <pm_enable_osc0_crystal+0x32>
8000228a:	e0 68 c6 bf 	mov	r8,50879
8000228e:	ea 18 00 2d 	orh	r8,0x2d
80002292:	10 3b       	cp.w	r11,r8
80002294:	e0 8b 00 04 	brhi	8000229c <pm_enable_osc0_crystal+0x20>
80002298:	30 5b       	mov	r11,5
8000229a:	c0 a8       	rjmp	800022ae <pm_enable_osc0_crystal+0x32>
8000229c:	e0 68 12 00 	mov	r8,4608
800022a0:	ea 18 00 7a 	orh	r8,0x7a
800022a4:	10 3b       	cp.w	r11,r8
800022a6:	f9 bb 03 06 	movlo	r11,6
800022aa:	f9 bb 02 07 	movhs	r11,7
800022ae:	f0 1f 00 02 	mcall	800022b4 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800022b2:	d8 02       	popm	pc
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	22 70       	sub	r0,39

800022b8 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800022b8:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800022ba:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800022be:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800022c0:	78 08       	ld.w	r8,r12[0x0]
800022c2:	a3 a8       	sbr	r8,0x2
800022c4:	99 08       	st.w	r12[0x0],r8
}
800022c6:	5e fc       	retal	r12

800022c8 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800022c8:	79 58       	ld.w	r8,r12[0x54]
800022ca:	e2 18 00 80 	andl	r8,0x80,COH
800022ce:	cf d0       	breq	800022c8 <pm_wait_for_clk0_ready>
}
800022d0:	5e fc       	retal	r12
800022d2:	d7 03       	nop

800022d4 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800022d4:	eb cd 40 80 	pushm	r7,lr
800022d8:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800022da:	f0 1f 00 04 	mcall	800022e8 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800022de:	0e 9c       	mov	r12,r7
800022e0:	f0 1f 00 03 	mcall	800022ec <pm_enable_clk0+0x18>
}
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	22 b8       	sub	r8,43
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	22 c8       	sub	r8,44

800022f0 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800022f0:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800022f2:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800022f6:	99 08       	st.w	r12[0x0],r8
}
800022f8:	5e fc       	retal	r12
800022fa:	d7 03       	nop

800022fc <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800022fc:	eb cd 40 c0 	pushm	r6-r7,lr
80002300:	18 97       	mov	r7,r12
80002302:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002304:	f0 1f 00 06 	mcall	8000231c <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002308:	0c 9b       	mov	r11,r6
8000230a:	0e 9c       	mov	r12,r7
8000230c:	f0 1f 00 05 	mcall	80002320 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002310:	30 1b       	mov	r11,1
80002312:	0e 9c       	mov	r12,r7
80002314:	f0 1f 00 04 	mcall	80002324 <pm_switch_to_osc0+0x28>
}
80002318:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000231c:	80 00       	ld.sh	r0,r0[0x0]
8000231e:	22 7c       	sub	r12,39
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	22 d4       	sub	r4,45
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	22 f0       	sub	r0,47

80002328 <pcl_switch_to_osc>:
        return PASS;
}
#endif // UC3D device-specific implementation

long int pcl_switch_to_osc(pcl_osc_t osc, unsigned int fcrystal, unsigned int startup)
{
80002328:	d4 01       	pushm	lr
#ifndef AVR32_PM_VERSION_RESETVALUE
// Implementation for UC3A, UC3A3, UC3B parts.
  if(PCL_OSC0 == osc)
8000232a:	58 0c       	cp.w	r12,0
8000232c:	c0 40       	breq	80002334 <pcl_switch_to_osc+0xc>
8000232e:	fe 7c d8 f0 	mov	r12,-10000
80002332:	d8 02       	popm	pc
  {
    // Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency,
    // enable the OSC0, set the main clock source as being OSC0.
    pm_switch_to_osc0(&AVR32_PM, fcrystal, startup);
80002334:	fe 7c 0c 00 	mov	r12,-62464
80002338:	f0 1f 00 02 	mcall	80002340 <pcl_switch_to_osc+0x18>
8000233c:	d8 0a       	popm	pc,r12=0
8000233e:	00 00       	add	r0,r0
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	22 fc       	sub	r12,47

80002344 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80002344:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002346:	f6 08 15 04 	lsl	r8,r11,0x4
8000234a:	14 38       	cp.w	r8,r10
8000234c:	f9 b8 08 10 	movls	r8,16
80002350:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80002354:	f0 0b 02 4b 	mul	r11,r8,r11
80002358:	f6 09 16 01 	lsr	r9,r11,0x1
8000235c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80002360:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80002364:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80002368:	f2 cb 00 01 	sub	r11,r9,1
8000236c:	e0 4b ff fe 	cp.w	r11,65534
80002370:	e0 88 00 03 	brls	80002376 <usart_set_async_baudrate+0x32>
80002374:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80002376:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80002378:	e8 6e 00 00 	mov	lr,524288
8000237c:	59 08       	cp.w	r8,16
8000237e:	fc 08 17 10 	movne	r8,lr
80002382:	f9 b8 00 00 	moveq	r8,0
80002386:	e4 1b ff f7 	andh	r11,0xfff7
8000238a:	e0 1b fe cf 	andl	r11,0xfecf
8000238e:	16 48       	or	r8,r11
80002390:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80002392:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80002396:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000239a:	99 89       	st.w	r12[0x20],r9
8000239c:	d8 0a       	popm	pc,r12=0

8000239e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000239e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800023a0:	e2 18 00 02 	andl	r8,0x2,COH
800023a4:	c0 31       	brne	800023aa <usart_write_char+0xc>
800023a6:	30 2c       	mov	r12,2
800023a8:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800023aa:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800023ae:	99 7b       	st.w	r12[0x1c],r11
800023b0:	5e fd       	retal	0
800023b2:	d7 03       	nop

800023b4 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800023b4:	eb cd 40 e0 	pushm	r5-r7,lr
800023b8:	18 96       	mov	r6,r12
800023ba:	16 95       	mov	r5,r11
800023bc:	e0 67 27 0f 	mov	r7,9999
800023c0:	c0 68       	rjmp	800023cc <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800023c2:	58 07       	cp.w	r7,0
800023c4:	c0 31       	brne	800023ca <usart_putchar+0x16>
800023c6:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800023ca:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800023cc:	0a 9b       	mov	r11,r5
800023ce:	0c 9c       	mov	r12,r6
800023d0:	f0 1f 00 03 	mcall	800023dc <usart_putchar+0x28>
800023d4:	cf 71       	brne	800023c2 <usart_putchar+0xe>

  return USART_SUCCESS;
}
800023d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800023da:	00 00       	add	r0,r0
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	23 9e       	sub	lr,57

800023e0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800023e0:	78 58       	ld.w	r8,r12[0x14]
800023e2:	e2 18 00 e0 	andl	r8,0xe0,COH
800023e6:	c0 30       	breq	800023ec <usart_read_char+0xc>
800023e8:	30 4c       	mov	r12,4
800023ea:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800023ec:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800023ee:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800023f2:	c0 31       	brne	800023f8 <usart_read_char+0x18>
800023f4:	30 3c       	mov	r12,3
800023f6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800023f8:	78 68       	ld.w	r8,r12[0x18]
800023fa:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800023fe:	97 08       	st.w	r11[0x0],r8
80002400:	5e fd       	retal	0

80002402 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80002402:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80002406:	e6 18 00 01 	andh	r8,0x1,COH
8000240a:	c0 71       	brne	80002418 <usart_reset+0x16>
8000240c:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000240e:	3f f8       	mov	r8,-1
80002410:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002412:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80002414:	d5 03       	csrf	0x10
80002416:	c0 48       	rjmp	8000241e <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80002418:	3f f8       	mov	r8,-1
8000241a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000241c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000241e:	30 08       	mov	r8,0
80002420:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80002422:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80002424:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80002426:	ea 68 61 0c 	mov	r8,680204
8000242a:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000242c:	5e fc       	retal	r12
8000242e:	d7 03       	nop

80002430 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80002430:	eb cd 40 e0 	pushm	r5-r7,lr
80002434:	18 96       	mov	r6,r12
80002436:	16 97       	mov	r7,r11
80002438:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000243a:	f0 1f 00 2f 	mcall	800024f4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000243e:	58 07       	cp.w	r7,0
80002440:	c5 80       	breq	800024f0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80002442:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002444:	30 49       	mov	r9,4
80002446:	f2 08 18 00 	cp.b	r8,r9
8000244a:	e0 88 00 53 	brls	800024f0 <usart_init_rs232+0xc0>
8000244e:	30 99       	mov	r9,9
80002450:	f2 08 18 00 	cp.b	r8,r9
80002454:	e0 8b 00 4e 	brhi	800024f0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80002458:	0f d9       	ld.ub	r9,r7[0x5]
8000245a:	30 78       	mov	r8,7
8000245c:	f0 09 18 00 	cp.b	r9,r8
80002460:	e0 8b 00 48 	brhi	800024f0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80002464:	8e 39       	ld.sh	r9,r7[0x6]
80002466:	e0 68 01 01 	mov	r8,257
8000246a:	f0 09 19 00 	cp.h	r9,r8
8000246e:	e0 8b 00 41 	brhi	800024f0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80002472:	ef 39 00 08 	ld.ub	r9,r7[8]
80002476:	30 38       	mov	r8,3
80002478:	f0 09 18 00 	cp.b	r9,r8
8000247c:	e0 8b 00 3a 	brhi	800024f0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002480:	0a 9a       	mov	r10,r5
80002482:	6e 0b       	ld.w	r11,r7[0x0]
80002484:	0c 9c       	mov	r12,r6
80002486:	f0 1f 00 1d 	mcall	800024f8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000248a:	58 1c       	cp.w	r12,1
8000248c:	c3 20       	breq	800024f0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000248e:	0f c8       	ld.ub	r8,r7[0x4]
80002490:	30 99       	mov	r9,9
80002492:	f2 08 18 00 	cp.b	r8,r9
80002496:	c0 51       	brne	800024a0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002498:	6c 18       	ld.w	r8,r6[0x4]
8000249a:	b1 b8       	sbr	r8,0x11
8000249c:	8d 18       	st.w	r6[0x4],r8
8000249e:	c0 68       	rjmp	800024aa <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800024a0:	6c 19       	ld.w	r9,r6[0x4]
800024a2:	20 58       	sub	r8,5
800024a4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800024a8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800024aa:	6c 19       	ld.w	r9,r6[0x4]
800024ac:	ef 3a 00 08 	ld.ub	r10,r7[8]
800024b0:	0f d8       	ld.ub	r8,r7[0x5]
800024b2:	a9 78       	lsl	r8,0x9
800024b4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800024b8:	12 48       	or	r8,r9
800024ba:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800024bc:	8e 38       	ld.sh	r8,r7[0x6]
800024be:	30 29       	mov	r9,2
800024c0:	f2 08 19 00 	cp.h	r8,r9
800024c4:	e0 88 00 09 	brls	800024d6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800024c8:	6c 18       	ld.w	r8,r6[0x4]
800024ca:	ad b8       	sbr	r8,0xd
800024cc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800024ce:	8e b8       	ld.uh	r8,r7[0x6]
800024d0:	20 28       	sub	r8,2
800024d2:	8d a8       	st.w	r6[0x28],r8
800024d4:	c0 68       	rjmp	800024e0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800024d6:	6c 19       	ld.w	r9,r6[0x4]
800024d8:	5c 78       	castu.h	r8
800024da:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800024de:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800024e0:	6c 18       	ld.w	r8,r6[0x4]
800024e2:	e0 18 ff f0 	andl	r8,0xfff0
800024e6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800024e8:	35 08       	mov	r8,80
800024ea:	8d 08       	st.w	r6[0x0],r8
800024ec:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800024f0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	24 02       	sub	r2,64
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	23 44       	sub	r4,52

800024fc <main>:
xQueueHandle xQueueRcv = NULL, xQueueTrx = NULL, xQueueLCD = NULL;



int main( void )
{
800024fc:	d4 01       	pushm	lr
	// Configure Osc0 in crystal mode (i.e. use of an external crystal source, with
	// frequency FOSC0) with an appropriate startup time then switch the main clock
	// source to Osc0.
	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
800024fe:	30 3a       	mov	r10,3
80002500:	e0 6b 1b 00 	mov	r11,6912
80002504:	ea 1b 00 b7 	orh	r11,0xb7
80002508:	30 0c       	mov	r12,0
8000250a:	f0 1f 00 0e 	mcall	80002540 <main+0x44>
	information.
	Note that the UC3L and UC3B parts do not have enough internal RAM to launch all the tasks of this example.
	That's why some of them are commented out using respectively #if (BOARD != UC3L_EK) or #if (BOARD != EVK1101)
	compiler directives. */
	
	xQueueRcv = xQueueCreate(10, sizeof(int)); //Rozmiar kolejki -> szybkoœæ transmisji, szybkoœæ procesora ~9600 -> 100ms na przygotowanie ramki dla tasku modelu ~~bufor na 11ramek
8000250e:	30 4b       	mov	r11,4
80002510:	30 ac       	mov	r12,10
80002512:	f0 1f 00 0d 	mcall	80002544 <main+0x48>
80002516:	48 d8       	lddpc	r8,80002548 <main+0x4c>
80002518:	91 0c       	st.w	r8[0x0],r12
	xQueueTrx = xQueueCreate(10, sizeof(int));
8000251a:	30 4b       	mov	r11,4
8000251c:	30 ac       	mov	r12,10
8000251e:	f0 1f 00 0a 	mcall	80002544 <main+0x48>
80002522:	48 b8       	lddpc	r8,8000254c <main+0x50>
80002524:	91 0c       	st.w	r8[0x0],r12
	
	//Tick zegara systemowego: 1200b -> 120znaków/s ~znak na ms -> zegar systemowy tick = przyjecie jednego znaku * 2
	vStartModelTask( mainLED_TASK_PRIORITY );
80002526:	30 1c       	mov	r12,1
80002528:	f0 1f 00 0a 	mcall	80002550 <main+0x54>
	vStartReceiveTask( mainLED_TASK_PRIORITY ); //wysoki priorytet co 5ms sprawdzanie taska i baud rate 1200 -> bo wtedy co 10ms cos przychodzi
8000252c:	30 1c       	mov	r12,1
8000252e:	f0 1f 00 0a 	mcall	80002554 <main+0x58>
	vStartTrxTask( mainLED_TASK_PRIORITY );
80002532:	30 1c       	mov	r12,1
80002534:	f0 1f 00 09 	mcall	80002558 <main+0x5c>


	/* Start the scheduler. */
	vTaskStartScheduler();
80002538:	f0 1f 00 09 	mcall	8000255c <main+0x60>

	/* Will only get here if there was insufficient memory to create the idle
	task. */

	return 0;
}
8000253c:	d8 0a       	popm	pc,r12=0
8000253e:	00 00       	add	r0,r0
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	23 28       	sub	r8,50
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	2e c0       	sub	r0,-20
80002548:	00 00       	add	r0,r0
8000254a:	06 34       	cp.w	r4,r3
8000254c:	00 00       	add	r0,r0
8000254e:	06 38       	cp.w	r8,r3
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	25 60       	sub	r0,86
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	26 58       	sub	r8,101
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	27 28       	sub	r8,114
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	36 2c       	mov	r12,98

80002560 <vStartModelTask>:
static portTASK_FUNCTION_PROTO( vModelTask, pvParameters );

/*-----------------------------------------------------------*/

void vStartModelTask( unsigned portBASE_TYPE uxPriority )
{
80002560:	d4 01       	pushm	lr

	/* Create the three tasks. */
	//for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )
	{
		/* Spawn the task. */
		xTaskCreate( vModelTask, ( signed char * ) "LEDx", ledSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
80002562:	30 09       	mov	r9,0
80002564:	1a d9       	st.w	--sp,r9
80002566:	1a d9       	st.w	--sp,r9
80002568:	1a d9       	st.w	--sp,r9
8000256a:	18 98       	mov	r8,r12
8000256c:	e0 6a 01 00 	mov	r10,256
80002570:	48 3b       	lddpc	r11,8000257c <vStartModelTask+0x1c>
80002572:	48 4c       	lddpc	r12,80002580 <vStartModelTask+0x20>
80002574:	f0 1f 00 04 	mcall	80002584 <vStartModelTask+0x24>
80002578:	2f dd       	sub	sp,-12
	}
}
8000257a:	d8 02       	popm	pc
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	48 b8       	lddpc	r8,800025a8 <vModelTask+0x20>
80002580:	80 00       	ld.sh	r0,r0[0x0]
80002582:	25 88       	sub	r8,88
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	34 48       	mov	r8,68

80002588 <vModelTask>:
float y = 0;
float c1 =50;
float c = 3 ;
float dt = 1;
static portTASK_FUNCTION( vModelTask, pvParameters )
{
80002588:	d4 31       	pushm	r0-r7,lr

	/* The parameters are not used. */
	( void ) pvParameters;

	/* Calculate the LED and flash rate. */
	portENTER_CRITICAL();
8000258a:	f0 1f 00 22 	mcall	80002610 <vModelTask+0x88>
		//uxLED = uxFlashTaskNumber;
		//uxLED = 1;
		/* Update so the next task uses the next LED. */
		//uxFlashTaskNumber++;
	}
	portEXIT_CRITICAL();
8000258e:	f0 1f 00 22 	mcall	80002614 <vModelTask+0x8c>


	for(;;)
	{
		if(xQueueReceive(xQueueRcv, &DataToReadModel, 10))
80002592:	4a 27       	lddpc	r7,80002618 <vModelTask+0x90>
80002594:	4a 23       	lddpc	r3,8000261c <vModelTask+0x94>
80002596:	30 05       	mov	r5,0
80002598:	30 a4       	mov	r4,10
		{			
			y += (DataToReadModel/c1 - ((y/c1*c)/10))*dt;
8000259a:	4a 22       	lddpc	r2,80002620 <vModelTask+0x98>
	portEXIT_CRITICAL();


	for(;;)
	{
		if(xQueueReceive(xQueueRcv, &DataToReadModel, 10))
8000259c:	0a 99       	mov	r9,r5
8000259e:	08 9a       	mov	r10,r4
800025a0:	0e 9b       	mov	r11,r7
800025a2:	66 0c       	ld.w	r12,r3[0x0]
800025a4:	f0 1f 00 20 	mcall	80002624 <vModelTask+0x9c>
800025a8:	c2 f0       	breq	80002606 <vModelTask+0x7e>
		{			
			y += (DataToReadModel/c1 - ((y/c1*c)/10))*dt;
800025aa:	4a 08       	lddpc	r8,80002628 <vModelTask+0xa0>
800025ac:	70 01       	ld.w	r1,r8[0x0]
800025ae:	64 00       	ld.w	r0,r2[0x0]
800025b0:	6e 0c       	ld.w	r12,r7[0x0]
800025b2:	f0 1f 00 1f 	mcall	8000262c <vModelTask+0xa4>
800025b6:	02 9b       	mov	r11,r1
800025b8:	f0 1f 00 1e 	mcall	80002630 <vModelTask+0xa8>
800025bc:	18 96       	mov	r6,r12
800025be:	02 9b       	mov	r11,r1
800025c0:	00 9c       	mov	r12,r0
800025c2:	f0 1f 00 1c 	mcall	80002630 <vModelTask+0xa8>
800025c6:	49 c8       	lddpc	r8,80002634 <vModelTask+0xac>
800025c8:	70 0b       	ld.w	r11,r8[0x0]
800025ca:	f0 1f 00 1c 	mcall	80002638 <vModelTask+0xb0>
800025ce:	fc 1b c1 20 	movh	r11,0xc120
800025d2:	f0 1f 00 18 	mcall	80002630 <vModelTask+0xa8>
800025d6:	18 9b       	mov	r11,r12
800025d8:	0c 9c       	mov	r12,r6
800025da:	f0 1f 00 19 	mcall	8000263c <vModelTask+0xb4>
800025de:	49 98       	lddpc	r8,80002640 <vModelTask+0xb8>
800025e0:	70 0b       	ld.w	r11,r8[0x0]
800025e2:	f0 1f 00 16 	mcall	80002638 <vModelTask+0xb0>
800025e6:	18 9b       	mov	r11,r12
800025e8:	00 9c       	mov	r12,r0
800025ea:	f0 1f 00 15 	mcall	8000263c <vModelTask+0xb4>
800025ee:	85 0c       	st.w	r2[0x0],r12
			DataToSendModel = (int)y;
800025f0:	49 56       	lddpc	r6,80002644 <vModelTask+0xbc>
800025f2:	f0 1f 00 16 	mcall	80002648 <vModelTask+0xc0>
800025f6:	8d 0c       	st.w	r6[0x0],r12
			xQueueSend(xQueueTrx, &DataToSendModel, 10);
800025f8:	0a 99       	mov	r9,r5
800025fa:	08 9a       	mov	r10,r4
800025fc:	0c 9b       	mov	r11,r6
800025fe:	49 48       	lddpc	r8,8000264c <vModelTask+0xc4>
80002600:	70 0c       	ld.w	r12,r8[0x0]
80002602:	f0 1f 00 14 	mcall	80002650 <vModelTask+0xc8>
		}
		
		
		vTaskDelay(5);
80002606:	30 5c       	mov	r12,5
80002608:	f0 1f 00 13 	mcall	80002654 <vModelTask+0xcc>
	}
8000260c:	cc 8b       	rjmp	8000259c <vModelTask+0x14>
8000260e:	00 00       	add	r0,r0
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	29 20       	sub	r0,-110
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	2a 2c       	sub	r12,-94
80002618:	00 00       	add	r0,r0
8000261a:	06 3c       	cp.w	r12,r3
8000261c:	00 00       	add	r0,r0
8000261e:	06 34       	cp.w	r4,r3
80002620:	00 00       	add	r0,r0
80002622:	06 40       	or	r0,r3
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	2c a4       	sub	r4,-54
80002628:	00 00       	add	r0,r0
8000262a:	00 24       	rsub	r4,r0
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	3a 3a       	mov	r10,-93
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	36 78       	mov	r8,103
80002634:	00 00       	add	r0,r0
80002636:	00 20       	rsub	r0,r0
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	39 58       	mov	r8,-107
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	38 ac       	mov	r12,-118
80002640:	00 00       	add	r0,r0
80002642:	00 1c       	sub	r12,r0
80002644:	00 00       	add	r0,r0
80002646:	06 44       	or	r4,r3
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	3a ae       	mov	lr,-86
8000264c:	00 00       	add	r0,r0
8000264e:	06 38       	cp.w	r8,r3
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	2d c0       	sub	r0,-36
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	33 28       	mov	r8,50

80002658 <vStartReceiveTask>:
		gpio_tgl_gpio_pin(LED0_GPIO); // Toggle the LED0.
	} while (j);
}

void vStartReceiveTask( unsigned portBASE_TYPE uxPriority )
{
80002658:	d4 01       	pushm	lr

	/* Create the three tasks. */
	//for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )
	{
		/* Spawn the task. */
		xTaskCreate( vRcvTask, ( signed char * ) "LEDx", ledSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
8000265a:	30 09       	mov	r9,0
8000265c:	1a d9       	st.w	--sp,r9
8000265e:	1a d9       	st.w	--sp,r9
80002660:	1a d9       	st.w	--sp,r9
80002662:	18 98       	mov	r8,r12
80002664:	e0 6a 01 00 	mov	r10,256
80002668:	48 3b       	lddpc	r11,80002674 <vStartReceiveTask+0x1c>
8000266a:	48 4c       	lddpc	r12,80002678 <vStartReceiveTask+0x20>
8000266c:	f0 1f 00 04 	mcall	8000267c <vStartReceiveTask+0x24>
80002670:	2f dd       	sub	sp,-12
	}
}
80002672:	d8 02       	popm	pc
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	48 b8       	lddpc	r8,800026a0 <vRcvTask+0x20>
80002678:	80 00       	ld.sh	r0,r0[0x0]
8000267a:	26 80       	sub	r0,104
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	34 48       	mov	r8,68

80002680 <vRcvTask>:
float DataToSend=0.0;
int res = 45;
int tmp = 200;
int tmp1=0;
static portTASK_FUNCTION( vRcvTask, pvParameters )
{
80002680:	d4 31       	pushm	r0-r7,lr

	/* Calculate the LED and flash rate. */
	portENTER_CRITICAL();
80002682:	f0 1f 00 1d 	mcall	800026f4 <vRcvTask+0x74>
		//uxLED = uxFlashTaskNumber;
		//uxLED = 1;
		/* Update so the next task uses the next LED. */
		//uxFlashTaskNumber++;
	}
	portEXIT_CRITICAL();
80002686:	f0 1f 00 1d 	mcall	800026f8 <vRcvTask+0x78>
	// Configure Osc0 in crystal mode (i.e. use of an external crystal source, with
	// frequency FOSC0) with an appropriate startup time then switch the main clock
	// source to Osc0.
	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
8000268a:	30 3a       	mov	r10,3
8000268c:	e0 6b 1b 00 	mov	r11,6912
80002690:	ea 1b 00 b7 	orh	r11,0xb7
80002694:	30 0c       	mov	r12,0
80002696:	f0 1f 00 1a 	mcall	800026fc <vRcvTask+0x7c>
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000269a:	30 2b       	mov	r11,2
8000269c:	49 9c       	lddpc	r12,80002700 <vRcvTask+0x80>
8000269e:	f0 1f 00 1a 	mcall	80002704 <vRcvTask+0x84>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);
800026a2:	e0 6a 1b 00 	mov	r10,6912
800026a6:	ea 1a 00 b7 	orh	r10,0xb7
800026aa:	49 8b       	lddpc	r11,80002708 <vRcvTask+0x88>
800026ac:	fe 7c 14 00 	mov	r12,-60416
800026b0:	f0 1f 00 17 	mcall	8000270c <vRcvTask+0x8c>
	
	
	//const TickType_t xBlockTime = pdMSTOTICKS(200);
	for(;;)
	{
		res = usart_read_char(EXAMPLE_USART, &receivedChar);
800026b4:	49 77       	lddpc	r7,80002710 <vRcvTask+0x90>
800026b6:	fe 76 14 00 	mov	r6,-60416
800026ba:	49 75       	lddpc	r5,80002714 <vRcvTask+0x94>
		{
			usart_reset_status(EXAMPLE_USART);
		}
		else if(res !=USART_RX_EMPTY)
		{ 
			if(!xQueueSend(xQueueRcv, (void*) &receivedChar, 10));
800026bc:	49 73       	lddpc	r3,80002718 <vRcvTask+0x98>
800026be:	30 02       	mov	r2,0
800026c0:	30 a1       	mov	r1,10
 *
 * \param usart   Base address of the USART instance.
 */
__always_inline static void usart_reset_status(volatile avr32_usart_t *usart)
{
  usart->cr = AVR32_USART_CR_RSTSTA_MASK;
800026c2:	e0 60 01 00 	mov	r0,256
			}
		}
		//else 		
			//xQueueSend(xQueueRcv, (void*) &tmp1, 10);
			//while(usart_putchar(EXAMPLE_USART, 47));
		vTaskDelay(5);
800026c6:	30 54       	mov	r4,5
	
	
	//const TickType_t xBlockTime = pdMSTOTICKS(200);
	for(;;)
	{
		res = usart_read_char(EXAMPLE_USART, &receivedChar);
800026c8:	0e 9b       	mov	r11,r7
800026ca:	0c 9c       	mov	r12,r6
800026cc:	f0 1f 00 14 	mcall	8000271c <vRcvTask+0x9c>
800026d0:	8b 0c       	st.w	r5[0x0],r12
		
		if ( res == USART_RX_ERROR)
800026d2:	58 4c       	cp.w	r12,4
800026d4:	c0 31       	brne	800026da <vRcvTask+0x5a>
800026d6:	8d 00       	st.w	r6[0x0],r0
800026d8:	c0 98       	rjmp	800026ea <vRcvTask+0x6a>
		{
			usart_reset_status(EXAMPLE_USART);
		}
		else if(res !=USART_RX_EMPTY)
800026da:	58 3c       	cp.w	r12,3
800026dc:	c0 70       	breq	800026ea <vRcvTask+0x6a>
		{ 
			if(!xQueueSend(xQueueRcv, (void*) &receivedChar, 10));
800026de:	04 99       	mov	r9,r2
800026e0:	02 9a       	mov	r10,r1
800026e2:	0e 9b       	mov	r11,r7
800026e4:	66 0c       	ld.w	r12,r3[0x0]
800026e6:	f0 1f 00 0f 	mcall	80002720 <vRcvTask+0xa0>
			}
		}
		//else 		
			//xQueueSend(xQueueRcv, (void*) &tmp1, 10);
			//while(usart_putchar(EXAMPLE_USART, 47));
		vTaskDelay(5);
800026ea:	08 9c       	mov	r12,r4
800026ec:	f0 1f 00 0e 	mcall	80002724 <vRcvTask+0xa4>
		/*
		 * Cpu now is in static sleep mode. When the wake-up external interrupt occurs,
		 * the CPU resumes execution back from the top of the while loop.
		 */
		
	}
800026f0:	ce cb       	rjmp	800026c8 <vRcvTask+0x48>
800026f2:	00 00       	add	r0,r0
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	29 20       	sub	r0,-110
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	2a 2c       	sub	r12,-94
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	23 28       	sub	r8,50
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	48 cc       	lddpc	r12,80002730 <vStartTrxTask+0x8>
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	21 30       	sub	r0,19
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	48 c0       	lddpc	r0,80002738 <vStartTrxTask+0x10>
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	24 30       	sub	r0,67
80002710:	00 00       	add	r0,r0
80002712:	00 2c       	rsub	r12,r0
80002714:	00 00       	add	r0,r0
80002716:	00 28       	rsub	r8,r0
80002718:	00 00       	add	r0,r0
8000271a:	06 34       	cp.w	r4,r3
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	23 e0       	sub	r0,62
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	2d c0       	sub	r0,-36
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	33 28       	mov	r8,50

80002728 <vStartTrxTask>:
static portTASK_FUNCTION_PROTO( vTrxTask, pvParameters );

/*-----------------------------------------------------------*/

void vStartTrxTask( unsigned portBASE_TYPE uxPriority )
{
80002728:	d4 01       	pushm	lr

	/* Create the three tasks. */
	//for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )
	{
		/* Spawn the task. */
		xTaskCreate( vTrxTask, ( signed char * ) "LEDx", ledSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
8000272a:	30 09       	mov	r9,0
8000272c:	1a d9       	st.w	--sp,r9
8000272e:	1a d9       	st.w	--sp,r9
80002730:	1a d9       	st.w	--sp,r9
80002732:	18 98       	mov	r8,r12
80002734:	e0 6a 01 00 	mov	r10,256
80002738:	48 3b       	lddpc	r11,80002744 <vStartTrxTask+0x1c>
8000273a:	48 4c       	lddpc	r12,80002748 <vStartTrxTask+0x20>
8000273c:	f0 1f 00 04 	mcall	8000274c <vStartTrxTask+0x24>
80002740:	2f dd       	sub	sp,-12
	}
}
80002742:	d8 02       	popm	pc
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	48 b8       	lddpc	r8,80002770 <vTrxTask+0x20>
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	27 50       	sub	r0,117
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	34 48       	mov	r8,68

80002750 <vTrxTask>:
/*-----------------------------------------------------------*/
int mama=(int)'a';
int DataToReadTRX=0;
int resTrx = 20;
static portTASK_FUNCTION( vTrxTask, pvParameters )
{
80002750:	eb cd 40 fe 	pushm	r1-r7,lr

	/* Calculate the LED and flash rate. */
	portENTER_CRITICAL();
80002754:	f0 1f 00 1c 	mcall	800027c4 <vTrxTask+0x74>
		//uxLED = uxFlashTaskNumber;
		//uxLED = 1;
		/* Update so the next task uses the next LED. */
		//uxFlashTaskNumber++;
	}
	portEXIT_CRITICAL();
80002758:	f0 1f 00 1c 	mcall	800027c8 <vTrxTask+0x78>
	
	// Configure Osc0 in crystal mode (i.e. use of an external crystal source, with
	// frequency FOSC0) with an appropriate startup time then switch the main clock
	// source to Osc0.
	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
8000275c:	30 3a       	mov	r10,3
8000275e:	e0 6b 1b 00 	mov	r11,6912
80002762:	ea 1b 00 b7 	orh	r11,0xb7
80002766:	30 0c       	mov	r12,0
80002768:	f0 1f 00 19 	mcall	800027cc <vTrxTask+0x7c>
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000276c:	30 2b       	mov	r11,2
8000276e:	49 9c       	lddpc	r12,800027d0 <vTrxTask+0x80>
80002770:	f0 1f 00 19 	mcall	800027d4 <vTrxTask+0x84>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);
80002774:	e0 6a 1b 00 	mov	r10,6912
80002778:	ea 1a 00 b7 	orh	r10,0xb7
8000277c:	49 7b       	lddpc	r11,800027d8 <vTrxTask+0x88>
8000277e:	fe 7c 14 00 	mov	r12,-60416
80002782:	f0 1f 00 17 	mcall	800027dc <vTrxTask+0x8c>
	
	for(;;)
	{
		resTrx= uxQueueMessagesWaiting(xQueueTrx);
80002786:	49 75       	lddpc	r5,800027e0 <vTrxTask+0x90>
80002788:	49 74       	lddpc	r4,800027e4 <vTrxTask+0x94>
		if(xQueueTrx != 0)
		{
			if(!xQueueReceive(xQueueTrx, (void*) &DataToReadTRX, 10))
8000278a:	49 87       	lddpc	r7,800027e8 <vTrxTask+0x98>
8000278c:	30 02       	mov	r2,0
8000278e:	30 a1       	mov	r1,10
			{
				if(resTrx != 0);
				{
				while(usart_putchar(EXAMPLE_USART, DataToReadTRX) != USART_SUCCESS);
80002790:	fe 76 14 00 	mov	r6,-60416
				}
			} 

			//while(usart_putchar(EXAMPLE_USART, 45));			
		}
		vTaskDelay(5);
80002794:	30 53       	mov	r3,5
	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);
	
	for(;;)
	{
		resTrx= uxQueueMessagesWaiting(xQueueTrx);
80002796:	6a 0c       	ld.w	r12,r5[0x0]
80002798:	f0 1f 00 15 	mcall	800027ec <vTrxTask+0x9c>
8000279c:	89 0c       	st.w	r4[0x0],r12
		if(xQueueTrx != 0)
8000279e:	6a 0c       	ld.w	r12,r5[0x0]
800027a0:	58 0c       	cp.w	r12,0
800027a2:	c0 c0       	breq	800027ba <vTrxTask+0x6a>
		{
			if(!xQueueReceive(xQueueTrx, (void*) &DataToReadTRX, 10))
800027a4:	04 99       	mov	r9,r2
800027a6:	02 9a       	mov	r10,r1
800027a8:	0e 9b       	mov	r11,r7
800027aa:	f0 1f 00 12 	mcall	800027f0 <vTrxTask+0xa0>
800027ae:	c0 61       	brne	800027ba <vTrxTask+0x6a>
			{
				if(resTrx != 0);
				{
				while(usart_putchar(EXAMPLE_USART, DataToReadTRX) != USART_SUCCESS);
800027b0:	6e 0b       	ld.w	r11,r7[0x0]
800027b2:	0c 9c       	mov	r12,r6
800027b4:	f0 1f 00 10 	mcall	800027f4 <vTrxTask+0xa4>
800027b8:	cf c1       	brne	800027b0 <vTrxTask+0x60>
				}
			} 

			//while(usart_putchar(EXAMPLE_USART, 45));			
		}
		vTaskDelay(5);
800027ba:	06 9c       	mov	r12,r3
800027bc:	f0 1f 00 0f 	mcall	800027f8 <vTrxTask+0xa8>
	}
800027c0:	ce bb       	rjmp	80002796 <vTrxTask+0x46>
800027c2:	00 00       	add	r0,r0
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	29 20       	sub	r0,-110
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	2a 2c       	sub	r12,-94
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	23 28       	sub	r8,50
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	48 dc       	lddpc	r12,80002804 <vListInitialise+0x8>
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	21 30       	sub	r0,19
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	48 ec       	lddpc	r12,80002810 <vListInitialiseItem>
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	24 30       	sub	r0,67
800027e0:	00 00       	add	r0,r0
800027e2:	06 38       	cp.w	r8,r3
800027e4:	00 00       	add	r0,r0
800027e6:	00 30       	cp.w	r0,r0
800027e8:	00 00       	add	r0,r0
800027ea:	06 48       	or	r8,r3
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	2b 50       	sub	r0,-75
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	2c a4       	sub	r4,-54
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	23 b4       	sub	r4,59
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	33 28       	mov	r8,50

800027fc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800027fc:	f8 c8 ff f8 	sub	r8,r12,-8
80002800:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80002802:	3f f9       	mov	r9,-1
80002804:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80002806:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80002808:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000280a:	30 08       	mov	r8,0
8000280c:	99 08       	st.w	r12[0x0],r8
}
8000280e:	5e fc       	retal	r12

80002810 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80002810:	30 08       	mov	r8,0
80002812:	99 48       	st.w	r12[0x10],r8
}
80002814:	5e fc       	retal	r12

80002816 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80002816:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80002818:	70 19       	ld.w	r9,r8[0x4]
8000281a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
8000281c:	78 19       	ld.w	r9,r12[0x4]
8000281e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002820:	70 19       	ld.w	r9,r8[0x4]
80002822:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80002824:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80002826:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002828:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000282a:	78 08       	ld.w	r8,r12[0x0]
8000282c:	2f f8       	sub	r8,-1
8000282e:	99 08       	st.w	r12[0x0],r8
}
80002830:	5e fc       	retal	r12

80002832 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80002832:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80002834:	5b fa       	cp.w	r10,-1
80002836:	c0 31       	brne	8000283c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80002838:	78 48       	ld.w	r8,r12[0x10]
8000283a:	c0 c8       	rjmp	80002852 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
8000283c:	f8 c8 ff f8 	sub	r8,r12,-8
80002840:	70 19       	ld.w	r9,r8[0x4]
80002842:	72 09       	ld.w	r9,r9[0x0]
80002844:	12 3a       	cp.w	r10,r9
80002846:	c0 63       	brcs	80002852 <vListInsert+0x20>
80002848:	70 18       	ld.w	r8,r8[0x4]
8000284a:	70 19       	ld.w	r9,r8[0x4]
8000284c:	72 09       	ld.w	r9,r9[0x0]
8000284e:	12 3a       	cp.w	r10,r9
80002850:	cf c2       	brcc	80002848 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80002852:	70 19       	ld.w	r9,r8[0x4]
80002854:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002856:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80002858:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000285a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000285c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000285e:	78 08       	ld.w	r8,r12[0x0]
80002860:	2f f8       	sub	r8,-1
80002862:	99 08       	st.w	r12[0x0],r8
}
80002864:	5e fc       	retal	r12

80002866 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002866:	78 18       	ld.w	r8,r12[0x4]
80002868:	78 29       	ld.w	r9,r12[0x8]
8000286a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000286c:	78 28       	ld.w	r8,r12[0x8]
8000286e:	78 19       	ld.w	r9,r12[0x4]
80002870:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80002872:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80002874:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80002876:	18 39       	cp.w	r9,r12
80002878:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
8000287c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80002880:	30 09       	mov	r9,0
80002882:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80002884:	70 09       	ld.w	r9,r8[0x0]
80002886:	20 19       	sub	r9,1
80002888:	91 09       	st.w	r8[0x0],r9
}
8000288a:	5e fc       	retal	r12

8000288c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000288c:	e0 68 08 08 	mov	r8,2056
80002890:	ea 18 08 08 	orh	r8,0x808
80002894:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80002896:	e0 68 09 09 	mov	r8,2313
8000289a:	ea 18 09 09 	orh	r8,0x909
8000289e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800028a0:	e0 68 0a 0a 	mov	r8,2570
800028a4:	ea 18 0a 0a 	orh	r8,0xa0a
800028a8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800028aa:	e0 68 0b 0b 	mov	r8,2827
800028ae:	ea 18 0b 0b 	orh	r8,0xb0b
800028b2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800028b4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800028b6:	e0 68 be ef 	mov	r8,48879
800028ba:	ea 18 de ad 	orh	r8,0xdead
800028be:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800028c0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800028c2:	fc 18 00 40 	movh	r8,0x40
800028c6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800028c8:	e0 68 00 ff 	mov	r8,255
800028cc:	ea 18 ff 00 	orh	r8,0xff00
800028d0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800028d2:	e0 68 01 01 	mov	r8,257
800028d6:	ea 18 01 01 	orh	r8,0x101
800028da:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800028dc:	e0 68 02 02 	mov	r8,514
800028e0:	ea 18 02 02 	orh	r8,0x202
800028e4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800028e6:	e0 68 03 03 	mov	r8,771
800028ea:	ea 18 03 03 	orh	r8,0x303
800028ee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800028f0:	e0 68 04 04 	mov	r8,1028
800028f4:	ea 18 04 04 	orh	r8,0x404
800028f8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800028fa:	e0 68 05 05 	mov	r8,1285
800028fe:	ea 18 05 05 	orh	r8,0x505
80002902:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80002904:	e0 68 06 06 	mov	r8,1542
80002908:	ea 18 06 06 	orh	r8,0x606
8000290c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000290e:	e0 68 07 07 	mov	r8,1799
80002912:	ea 18 07 07 	orh	r8,0x707
80002916:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80002918:	30 08       	mov	r8,0
8000291a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000291c:	5e fc       	retal	r12
8000291e:	d7 03       	nop

80002920 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80002920:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80002922:	48 38       	lddpc	r8,8000292c <vPortEnterCritical+0xc>
80002924:	70 09       	ld.w	r9,r8[0x0]
80002926:	2f f9       	sub	r9,-1
80002928:	91 09       	st.w	r8[0x0],r9
}
8000292a:	5e fc       	retal	r12
8000292c:	00 00       	add	r0,r0
8000292e:	00 34       	cp.w	r4,r0

80002930 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80002930:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80002932:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80002934:	30 0a       	mov	r10,0
80002936:	14 9b       	mov	r11,r10
80002938:	49 2c       	lddpc	r12,80002980 <xPortStartScheduler+0x50>
8000293a:	f0 1f 00 13 	mcall	80002984 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000293e:	e0 68 2e e0 	mov	r8,12000
80002942:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80002946:	30 08       	mov	r8,0
80002948:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000294c:	e0 68 07 1c 	mov	r8,1820
80002950:	ea 18 00 00 	orh	r8,0x0
80002954:	70 00       	ld.w	r0,r8[0x0]
80002956:	60 0d       	ld.w	sp,r0[0x0]
80002958:	1b 00       	ld.w	r0,sp++
8000295a:	e0 68 00 34 	mov	r8,52
8000295e:	ea 18 00 00 	orh	r8,0x0
80002962:	91 00       	st.w	r8[0x0],r0
80002964:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002968:	2f ed       	sub	sp,-8
8000296a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000296e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80002972:	e3 b0 00 00 	mtsr	0x0,r0
80002976:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000297a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000297e:	d8 0a       	popm	pc,r12=0
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	2a 4c       	sub	r12,-92
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	21 64       	sub	r4,22

80002988 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80002988:	20 6d       	sub	sp,24
8000298a:	eb cd 00 ff 	pushm	r0-r7
8000298e:	fa c7 ff c0 	sub	r7,sp,-64
80002992:	ee f0 ff f8 	ld.w	r0,r7[-8]
80002996:	ef 40 ff e0 	st.w	r7[-32],r0
8000299a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000299e:	ef 40 ff e4 	st.w	r7[-28],r0
800029a2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800029a6:	e0 68 00 34 	mov	r8,52
800029aa:	ea 18 00 00 	orh	r8,0x0
800029ae:	70 00       	ld.w	r0,r8[0x0]
800029b0:	1a d0       	st.w	--sp,r0
800029b2:	f0 1f 00 1a 	mcall	80002a18 <LABEL_RET_SCALL_260+0x14>
800029b6:	e0 68 07 1c 	mov	r8,1820
800029ba:	ea 18 00 00 	orh	r8,0x0
800029be:	70 00       	ld.w	r0,r8[0x0]
800029c0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800029c2:	f0 1f 00 17 	mcall	80002a1c <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
800029c6:	e0 68 07 1c 	mov	r8,1820
800029ca:	ea 18 00 00 	orh	r8,0x0
800029ce:	70 00       	ld.w	r0,r8[0x0]
800029d0:	60 0d       	ld.w	sp,r0[0x0]
800029d2:	1b 00       	ld.w	r0,sp++
800029d4:	e0 68 00 34 	mov	r8,52
800029d8:	ea 18 00 00 	orh	r8,0x0
800029dc:	91 00       	st.w	r8[0x0],r0
800029de:	fa c7 ff d8 	sub	r7,sp,-40
800029e2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800029e6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800029ea:	e0 61 00 34 	mov	r1,52
800029ee:	ea 11 00 00 	orh	r1,0x0
800029f2:	62 02       	ld.w	r2,r1[0x0]
800029f4:	58 02       	cp.w	r2,0
800029f6:	c0 70       	breq	80002a04 <LABEL_RET_SCALL_260>
800029f8:	e4 c2 00 01 	sub	r2,r2,1
800029fc:	83 02       	st.w	r1[0x0],r2
800029fe:	58 02       	cp.w	r2,0
80002a00:	c0 21       	brne	80002a04 <LABEL_RET_SCALL_260>
80002a02:	b1 c0       	cbr	r0,0x10

80002a04 <LABEL_RET_SCALL_260>:
80002a04:	ef 40 ff f8 	st.w	r7[-8],r0
80002a08:	ee f0 ff e4 	ld.w	r0,r7[-28]
80002a0c:	ef 40 ff fc 	st.w	r7[-4],r0
80002a10:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002a14:	2f ad       	sub	sp,-24
80002a16:	d6 13       	rets
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	29 20       	sub	r0,-110
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	2f 44       	sub	r4,-12

80002a20 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80002a20:	e1 b8 00 43 	mfsr	r8,0x10c
80002a24:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80002a28:	5e fc       	retal	r12
80002a2a:	d7 03       	nop

80002a2c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80002a2c:	48 78       	lddpc	r8,80002a48 <vPortExitCritical+0x1c>
80002a2e:	70 08       	ld.w	r8,r8[0x0]
80002a30:	58 08       	cp.w	r8,0
80002a32:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80002a34:	48 58       	lddpc	r8,80002a48 <vPortExitCritical+0x1c>
80002a36:	70 09       	ld.w	r9,r8[0x0]
80002a38:	20 19       	sub	r9,1
80002a3a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80002a3c:	70 08       	ld.w	r8,r8[0x0]
80002a3e:	58 08       	cp.w	r8,0
80002a40:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80002a42:	d5 03       	csrf	0x10
80002a44:	5e fc       	retal	r12
80002a46:	00 00       	add	r0,r0
80002a48:	00 00       	add	r0,r0
80002a4a:	00 34       	cp.w	r4,r0

80002a4c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80002a4c:	eb cd 00 ff 	pushm	r0-r7
80002a50:	e0 68 00 34 	mov	r8,52
80002a54:	ea 18 00 00 	orh	r8,0x0
80002a58:	70 00       	ld.w	r0,r8[0x0]
80002a5a:	1a d0       	st.w	--sp,r0
80002a5c:	7a 90       	ld.w	r0,sp[0x24]
80002a5e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002a62:	58 10       	cp.w	r0,1
80002a64:	e0 8b 00 08 	brhi	80002a74 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80002a68:	e0 68 07 1c 	mov	r8,1820
80002a6c:	ea 18 00 00 	orh	r8,0x0
80002a70:	70 00       	ld.w	r0,r8[0x0]
80002a72:	81 0d       	st.w	r0[0x0],sp

80002a74 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80002a74:	f0 1f 00 12 	mcall	80002abc <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80002a78:	f0 1f 00 12 	mcall	80002ac0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80002a7c:	f0 1f 00 12 	mcall	80002ac4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80002a80:	f0 1f 00 12 	mcall	80002ac8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80002a84:	7a 90       	ld.w	r0,sp[0x24]
80002a86:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002a8a:	58 10       	cp.w	r0,1
80002a8c:	e0 8b 00 0e 	brhi	80002aa8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80002a90:	f0 1f 00 0c 	mcall	80002ac0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80002a94:	f0 1f 00 0e 	mcall	80002acc <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80002a98:	f0 1f 00 0c 	mcall	80002ac8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80002a9c:	e0 68 07 1c 	mov	r8,1820
80002aa0:	ea 18 00 00 	orh	r8,0x0
80002aa4:	70 00       	ld.w	r0,r8[0x0]
80002aa6:	60 0d       	ld.w	sp,r0[0x0]

80002aa8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80002aa8:	1b 00       	ld.w	r0,sp++
80002aaa:	e0 68 00 34 	mov	r8,52
80002aae:	ea 18 00 00 	orh	r8,0x0
80002ab2:	91 00       	st.w	r8[0x0],r0
80002ab4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002ab8:	d6 03       	rete
80002aba:	00 00       	add	r0,r0
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	2a 20       	sub	r0,-94
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	29 20       	sub	r0,-110
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	30 d0       	mov	r0,13
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	2a 2c       	sub	r12,-94
80002acc:	80 00       	ld.sh	r0,r0[0x0]
80002ace:	2f 44       	sub	r4,-12

80002ad0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80002ad0:	d4 01       	pushm	lr
	vTaskSuspendAll();
80002ad2:	f0 1f 00 02 	mcall	80002ad8 <__malloc_lock+0x8>
}
80002ad6:	d8 02       	popm	pc
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	2f 34       	sub	r4,-13

80002adc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80002adc:	d4 01       	pushm	lr
	xTaskResumeAll();
80002ade:	f0 1f 00 02 	mcall	80002ae4 <__malloc_unlock+0x8>
}
80002ae2:	d8 02       	popm	pc
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	31 e4       	mov	r4,30

80002ae8 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80002ae8:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80002aea:	48 48       	lddpc	r8,80002af8 <_init_startup+0x10>
80002aec:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80002af0:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80002af2:	f0 1f 00 03 	mcall	80002afc <_init_startup+0x14>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
80002af6:	da 0a       	popm	pc,r12=1
80002af8:	80 00       	ld.sh	r0,r0[0x0]
80002afa:	46 00       	lddsp	r0,sp[0x180]
80002afc:	80 00       	ld.sh	r0,r0[0x0]
80002afe:	21 e4       	sub	r4,30

80002b00 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80002b00:	eb cd 40 80 	pushm	r7,lr
80002b04:	18 97       	mov	r7,r12
	if( pv )
80002b06:	58 0c       	cp.w	r12,0
80002b08:	c0 80       	breq	80002b18 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80002b0a:	f0 1f 00 05 	mcall	80002b1c <vPortFree+0x1c>
		{
			free( pv );
80002b0e:	0e 9c       	mov	r12,r7
80002b10:	f0 1f 00 04 	mcall	80002b20 <vPortFree+0x20>
		}
		xTaskResumeAll();
80002b14:	f0 1f 00 04 	mcall	80002b24 <vPortFree+0x24>
80002b18:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b1c:	80 00       	ld.sh	r0,r0[0x0]
80002b1e:	2f 34       	sub	r4,-13
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	3a fc       	mov	r12,-81
80002b24:	80 00       	ld.sh	r0,r0[0x0]
80002b26:	31 e4       	mov	r4,30

80002b28 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80002b28:	eb cd 40 80 	pushm	r7,lr
80002b2c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80002b2e:	f0 1f 00 06 	mcall	80002b44 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80002b32:	0e 9c       	mov	r12,r7
80002b34:	f0 1f 00 05 	mcall	80002b48 <pvPortMalloc+0x20>
80002b38:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80002b3a:	f0 1f 00 05 	mcall	80002b4c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80002b3e:	0e 9c       	mov	r12,r7
80002b40:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b44:	80 00       	ld.sh	r0,r0[0x0]
80002b46:	2f 34       	sub	r4,-13
80002b48:	80 00       	ld.sh	r0,r0[0x0]
80002b4a:	3b 0c       	mov	r12,-80
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	31 e4       	mov	r4,30

80002b50 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
80002b50:	eb cd 40 80 	pushm	r7,lr
80002b54:	18 97       	mov	r7,r12
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
80002b56:	f0 1f 00 05 	mcall	80002b68 <uxQueueMessagesWaiting+0x18>
		uxReturn = pxQueue->uxMessagesWaiting;
80002b5a:	6e e7       	ld.w	r7,r7[0x38]
	taskEXIT_CRITICAL();
80002b5c:	f0 1f 00 04 	mcall	80002b6c <uxQueueMessagesWaiting+0x1c>

	return uxReturn;
}
80002b60:	0e 9c       	mov	r12,r7
80002b62:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b66:	00 00       	add	r0,r0
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	29 20       	sub	r0,-110
80002b6c:	80 00       	ld.sh	r0,r0[0x0]
80002b6e:	2a 2c       	sub	r12,-94

80002b70 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80002b70:	d4 01       	pushm	lr
80002b72:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80002b74:	78 09       	ld.w	r9,r12[0x0]
80002b76:	58 09       	cp.w	r9,0
80002b78:	c1 10       	breq	80002b9a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80002b7a:	78 3a       	ld.w	r10,r12[0xc]
80002b7c:	79 09       	ld.w	r9,r12[0x40]
80002b7e:	f4 09 00 09 	add	r9,r10,r9
80002b82:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80002b84:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80002b86:	14 39       	cp.w	r9,r10
80002b88:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80002b8c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80002b90:	79 0a       	ld.w	r10,r12[0x40]
80002b92:	78 3b       	ld.w	r11,r12[0xc]
80002b94:	10 9c       	mov	r12,r8
80002b96:	f0 1f 00 02 	mcall	80002b9c <prvCopyDataFromQueue+0x2c>
80002b9a:	d8 02       	popm	pc
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	3f 50       	mov	r0,-11

80002ba0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80002ba0:	eb cd 40 80 	pushm	r7,lr
80002ba4:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80002ba6:	79 08       	ld.w	r8,r12[0x40]
80002ba8:	58 08       	cp.w	r8,0
80002baa:	c2 50       	breq	80002bf4 <prvCopyDataToQueue+0x54>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80002bac:	58 0a       	cp.w	r10,0
80002bae:	c1 01       	brne	80002bce <prvCopyDataToQueue+0x2e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80002bb0:	10 9a       	mov	r10,r8
80002bb2:	78 2c       	ld.w	r12,r12[0x8]
80002bb4:	f0 1f 00 13 	mcall	80002c00 <prvCopyDataToQueue+0x60>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80002bb8:	6e 29       	ld.w	r9,r7[0x8]
80002bba:	6f 08       	ld.w	r8,r7[0x40]
80002bbc:	f2 08 00 08 	add	r8,r9,r8
80002bc0:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80002bc2:	6e 19       	ld.w	r9,r7[0x4]
80002bc4:	12 38       	cp.w	r8,r9
80002bc6:	c1 73       	brcs	80002bf4 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80002bc8:	6e 08       	ld.w	r8,r7[0x0]
80002bca:	8f 28       	st.w	r7[0x8],r8
80002bcc:	c1 48       	rjmp	80002bf4 <prvCopyDataToQueue+0x54>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80002bce:	10 9a       	mov	r10,r8
80002bd0:	78 3c       	ld.w	r12,r12[0xc]
80002bd2:	f0 1f 00 0c 	mcall	80002c00 <prvCopyDataToQueue+0x60>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80002bd6:	6f 08       	ld.w	r8,r7[0x40]
80002bd8:	6e 39       	ld.w	r9,r7[0xc]
80002bda:	f2 08 01 08 	sub	r8,r9,r8
80002bde:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80002be0:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80002be2:	12 38       	cp.w	r8,r9
80002be4:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80002be8:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80002bec:	f3 d8 e3 19 	subcs	r9,r9,r8
80002bf0:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80002bf4:	6e e8       	ld.w	r8,r7[0x38]
80002bf6:	2f f8       	sub	r8,-1
80002bf8:	8f e8       	st.w	r7[0x38],r8
}
80002bfa:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bfe:	00 00       	add	r0,r0
80002c00:	80 00       	ld.sh	r0,r0[0x0]
80002c02:	3f 50       	mov	r0,-11

80002c04 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80002c04:	eb cd 40 c0 	pushm	r6-r7,lr
80002c08:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80002c0a:	f0 1f 00 23 	mcall	80002c94 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002c0e:	6f 28       	ld.w	r8,r7[0x48]
80002c10:	58 08       	cp.w	r8,0
80002c12:	e0 8a 00 18 	brle	80002c42 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002c16:	6e 98       	ld.w	r8,r7[0x24]
80002c18:	58 08       	cp.w	r8,0
80002c1a:	c1 40       	breq	80002c42 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002c1c:	ee c6 ff dc 	sub	r6,r7,-36
80002c20:	c0 48       	rjmp	80002c28 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002c22:	6e 98       	ld.w	r8,r7[0x24]
80002c24:	58 08       	cp.w	r8,0
80002c26:	c0 e0       	breq	80002c42 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002c28:	0c 9c       	mov	r12,r6
80002c2a:	f0 1f 00 1c 	mcall	80002c98 <prvUnlockQueue+0x94>
80002c2e:	c0 30       	breq	80002c34 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80002c30:	f0 1f 00 1b 	mcall	80002c9c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80002c34:	6f 28       	ld.w	r8,r7[0x48]
80002c36:	20 18       	sub	r8,1
80002c38:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002c3c:	58 08       	cp.w	r8,0
80002c3e:	fe 99 ff f2 	brgt	80002c22 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80002c42:	3f f8       	mov	r8,-1
80002c44:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80002c48:	f0 1f 00 16 	mcall	80002ca0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80002c4c:	f0 1f 00 12 	mcall	80002c94 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002c50:	6f 18       	ld.w	r8,r7[0x44]
80002c52:	58 08       	cp.w	r8,0
80002c54:	e0 8a 00 18 	brle	80002c84 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002c58:	6e 48       	ld.w	r8,r7[0x10]
80002c5a:	58 08       	cp.w	r8,0
80002c5c:	c1 40       	breq	80002c84 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002c5e:	ee c6 ff f0 	sub	r6,r7,-16
80002c62:	c0 48       	rjmp	80002c6a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002c64:	6e 48       	ld.w	r8,r7[0x10]
80002c66:	58 08       	cp.w	r8,0
80002c68:	c0 e0       	breq	80002c84 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002c6a:	0c 9c       	mov	r12,r6
80002c6c:	f0 1f 00 0b 	mcall	80002c98 <prvUnlockQueue+0x94>
80002c70:	c0 30       	breq	80002c76 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80002c72:	f0 1f 00 0b 	mcall	80002c9c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80002c76:	6f 18       	ld.w	r8,r7[0x44]
80002c78:	20 18       	sub	r8,1
80002c7a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002c7e:	58 08       	cp.w	r8,0
80002c80:	fe 99 ff f2 	brgt	80002c64 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80002c84:	3f f8       	mov	r8,-1
80002c86:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80002c8a:	f0 1f 00 06 	mcall	80002ca0 <prvUnlockQueue+0x9c>
}
80002c8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c92:	00 00       	add	r0,r0
80002c94:	80 00       	ld.sh	r0,r0[0x0]
80002c96:	29 20       	sub	r0,-110
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	30 54       	mov	r4,5
80002c9c:	80 00       	ld.sh	r0,r0[0x0]
80002c9e:	2f d8       	sub	r8,-3
80002ca0:	80 00       	ld.sh	r0,r0[0x0]
80002ca2:	2a 2c       	sub	r12,-94

80002ca4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80002ca4:	d4 31       	pushm	r0-r7,lr
80002ca6:	20 5d       	sub	sp,20
80002ca8:	18 97       	mov	r7,r12
80002caa:	50 0b       	stdsp	sp[0x0],r11
80002cac:	50 2a       	stdsp	sp[0x8],r10
80002cae:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002cb0:	f8 c1 ff dc 	sub	r1,r12,-36
80002cb4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002cb6:	fa c4 ff f4 	sub	r4,sp,-12
80002cba:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80002cbc:	0a 92       	mov	r2,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002cbe:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80002cc2:	f0 1f 00 36 	mcall	80002d98 <xQueueGenericReceive+0xf4>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80002cc6:	6e e8       	ld.w	r8,r7[0x38]
80002cc8:	58 08       	cp.w	r8,0
80002cca:	c2 40       	breq	80002d12 <xQueueGenericReceive+0x6e>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80002ccc:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80002cce:	40 0b       	lddsp	r11,sp[0x0]
80002cd0:	0e 9c       	mov	r12,r7
80002cd2:	f0 1f 00 33 	mcall	80002d9c <xQueueGenericReceive+0xf8>

				if( xJustPeeking == pdFALSE )
80002cd6:	40 18       	lddsp	r8,sp[0x4]
80002cd8:	58 08       	cp.w	r8,0
80002cda:	c0 f1       	brne	80002cf8 <xQueueGenericReceive+0x54>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80002cdc:	6e e8       	ld.w	r8,r7[0x38]
80002cde:	20 18       	sub	r8,1
80002ce0:	8f e8       	st.w	r7[0x38],r8
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002ce2:	6e 48       	ld.w	r8,r7[0x10]
80002ce4:	58 08       	cp.w	r8,0
80002ce6:	c1 20       	breq	80002d0a <xQueueGenericReceive+0x66>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80002ce8:	ee cc ff f0 	sub	r12,r7,-16
80002cec:	f0 1f 00 2d 	mcall	80002da0 <xQueueGenericReceive+0xfc>
80002cf0:	58 1c       	cp.w	r12,1
80002cf2:	c0 c1       	brne	80002d0a <xQueueGenericReceive+0x66>
						{
							portYIELD_WITHIN_API();
80002cf4:	d7 33       	scall
80002cf6:	c0 a8       	rjmp	80002d0a <xQueueGenericReceive+0x66>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80002cf8:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002cfa:	6e 98       	ld.w	r8,r7[0x24]
80002cfc:	58 08       	cp.w	r8,0
80002cfe:	c0 60       	breq	80002d0a <xQueueGenericReceive+0x66>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002d00:	02 9c       	mov	r12,r1
80002d02:	f0 1f 00 28 	mcall	80002da0 <xQueueGenericReceive+0xfc>
80002d06:	c0 20       	breq	80002d0a <xQueueGenericReceive+0x66>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80002d08:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80002d0a:	f0 1f 00 27 	mcall	80002da4 <xQueueGenericReceive+0x100>
80002d0e:	30 1c       	mov	r12,1
				return pdPASS;
80002d10:	c4 28       	rjmp	80002d94 <xQueueGenericReceive+0xf0>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80002d12:	40 28       	lddsp	r8,sp[0x8]
80002d14:	58 08       	cp.w	r8,0
80002d16:	c0 51       	brne	80002d20 <xQueueGenericReceive+0x7c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80002d18:	f0 1f 00 23 	mcall	80002da4 <xQueueGenericReceive+0x100>
80002d1c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80002d1e:	c3 b8       	rjmp	80002d94 <xQueueGenericReceive+0xf0>
				}
				else if( xEntryTimeSet == pdFALSE )
80002d20:	58 05       	cp.w	r5,0
80002d22:	c0 51       	brne	80002d2c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002d24:	08 9c       	mov	r12,r4
80002d26:	f0 1f 00 21 	mcall	80002da8 <xQueueGenericReceive+0x104>
80002d2a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80002d2c:	f0 1f 00 1e 	mcall	80002da4 <xQueueGenericReceive+0x100>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80002d30:	f0 1f 00 1f 	mcall	80002dac <xQueueGenericReceive+0x108>
		prvLockQueue( pxQueue );
80002d34:	f0 1f 00 19 	mcall	80002d98 <xQueueGenericReceive+0xf4>
80002d38:	6f 18       	ld.w	r8,r7[0x44]
80002d3a:	5b f8       	cp.w	r8,-1
80002d3c:	ef f2 0a 11 	st.weq	r7[0x44],r2
80002d40:	6f 28       	ld.w	r8,r7[0x48]
80002d42:	5b f8       	cp.w	r8,-1
80002d44:	ef f2 0a 12 	st.weq	r7[0x48],r2
80002d48:	f0 1f 00 17 	mcall	80002da4 <xQueueGenericReceive+0x100>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002d4c:	06 9b       	mov	r11,r3
80002d4e:	08 9c       	mov	r12,r4
80002d50:	f0 1f 00 18 	mcall	80002db0 <xQueueGenericReceive+0x10c>
80002d54:	c1 a1       	brne	80002d88 <xQueueGenericReceive+0xe4>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80002d56:	f0 1f 00 11 	mcall	80002d98 <xQueueGenericReceive+0xf4>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80002d5a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80002d5c:	f0 1f 00 12 	mcall	80002da4 <xQueueGenericReceive+0x100>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80002d60:	58 06       	cp.w	r6,0
80002d62:	c0 d1       	brne	80002d7c <xQueueGenericReceive+0xd8>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002d64:	40 2b       	lddsp	r11,sp[0x8]
80002d66:	02 9c       	mov	r12,r1
80002d68:	f0 1f 00 13 	mcall	80002db4 <xQueueGenericReceive+0x110>
				prvUnlockQueue( pxQueue );
80002d6c:	0e 9c       	mov	r12,r7
80002d6e:	f0 1f 00 13 	mcall	80002db8 <xQueueGenericReceive+0x114>
				if( !xTaskResumeAll() )
80002d72:	f0 1f 00 13 	mcall	80002dbc <xQueueGenericReceive+0x118>
80002d76:	ca 61       	brne	80002cc2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80002d78:	d7 33       	scall
80002d7a:	ca 4b       	rjmp	80002cc2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80002d7c:	0e 9c       	mov	r12,r7
80002d7e:	f0 1f 00 0f 	mcall	80002db8 <xQueueGenericReceive+0x114>
				( void ) xTaskResumeAll();
80002d82:	f0 1f 00 0f 	mcall	80002dbc <xQueueGenericReceive+0x118>
80002d86:	c9 eb       	rjmp	80002cc2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80002d88:	0e 9c       	mov	r12,r7
80002d8a:	f0 1f 00 0c 	mcall	80002db8 <xQueueGenericReceive+0x114>
			( void ) xTaskResumeAll();
80002d8e:	f0 1f 00 0c 	mcall	80002dbc <xQueueGenericReceive+0x118>
80002d92:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80002d94:	2f bd       	sub	sp,-20
80002d96:	d8 32       	popm	r0-r7,pc
80002d98:	80 00       	ld.sh	r0,r0[0x0]
80002d9a:	29 20       	sub	r0,-110
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	2b 70       	sub	r0,-73
80002da0:	80 00       	ld.sh	r0,r0[0x0]
80002da2:	30 54       	mov	r4,5
80002da4:	80 00       	ld.sh	r0,r0[0x0]
80002da6:	2a 2c       	sub	r12,-94
80002da8:	80 00       	ld.sh	r0,r0[0x0]
80002daa:	2f c0       	sub	r0,-4
80002dac:	80 00       	ld.sh	r0,r0[0x0]
80002dae:	2f 34       	sub	r4,-13
80002db0:	80 00       	ld.sh	r0,r0[0x0]
80002db2:	2f e4       	sub	r4,-2
80002db4:	80 00       	ld.sh	r0,r0[0x0]
80002db6:	33 70       	mov	r0,55
80002db8:	80 00       	ld.sh	r0,r0[0x0]
80002dba:	2c 04       	sub	r4,-64
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	31 e4       	mov	r4,30

80002dc0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80002dc0:	d4 31       	pushm	r0-r7,lr
80002dc2:	20 5d       	sub	sp,20
80002dc4:	18 97       	mov	r7,r12
80002dc6:	50 0b       	stdsp	sp[0x0],r11
80002dc8:	50 2a       	stdsp	sp[0x8],r10
80002dca:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80002dcc:	f8 c0 ff f0 	sub	r0,r12,-16
80002dd0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002dd2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80002dd6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002dd8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80002ddc:	f0 1f 00 2f 	mcall	80002e98 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80002de0:	6e e9       	ld.w	r9,r7[0x38]
80002de2:	6e f8       	ld.w	r8,r7[0x3c]
80002de4:	10 39       	cp.w	r9,r8
80002de6:	c1 42       	brcc	80002e0e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80002de8:	40 1a       	lddsp	r10,sp[0x4]
80002dea:	40 0b       	lddsp	r11,sp[0x0]
80002dec:	0e 9c       	mov	r12,r7
80002dee:	f0 1f 00 2c 	mcall	80002e9c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002df2:	6e 98       	ld.w	r8,r7[0x24]
80002df4:	58 08       	cp.w	r8,0
80002df6:	c0 80       	breq	80002e06 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80002df8:	ee cc ff dc 	sub	r12,r7,-36
80002dfc:	f0 1f 00 29 	mcall	80002ea0 <xQueueGenericSend+0xe0>
80002e00:	58 1c       	cp.w	r12,1
80002e02:	c0 21       	brne	80002e06 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80002e04:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80002e06:	f0 1f 00 28 	mcall	80002ea4 <xQueueGenericSend+0xe4>
80002e0a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80002e0c:	c4 38       	rjmp	80002e92 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80002e0e:	40 28       	lddsp	r8,sp[0x8]
80002e10:	58 08       	cp.w	r8,0
80002e12:	c0 51       	brne	80002e1c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80002e14:	f0 1f 00 24 	mcall	80002ea4 <xQueueGenericSend+0xe4>
80002e18:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80002e1a:	c3 c8       	rjmp	80002e92 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80002e1c:	58 04       	cp.w	r4,0
80002e1e:	c0 51       	brne	80002e28 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002e20:	06 9c       	mov	r12,r3
80002e22:	f0 1f 00 22 	mcall	80002ea8 <xQueueGenericSend+0xe8>
80002e26:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80002e28:	f0 1f 00 1f 	mcall	80002ea4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80002e2c:	f0 1f 00 20 	mcall	80002eac <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80002e30:	f0 1f 00 1a 	mcall	80002e98 <xQueueGenericSend+0xd8>
80002e34:	6f 18       	ld.w	r8,r7[0x44]
80002e36:	5b f8       	cp.w	r8,-1
80002e38:	ef f1 0a 11 	st.weq	r7[0x44],r1
80002e3c:	6f 28       	ld.w	r8,r7[0x48]
80002e3e:	5b f8       	cp.w	r8,-1
80002e40:	ef f1 0a 12 	st.weq	r7[0x48],r1
80002e44:	f0 1f 00 18 	mcall	80002ea4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002e48:	04 9b       	mov	r11,r2
80002e4a:	06 9c       	mov	r12,r3
80002e4c:	f0 1f 00 19 	mcall	80002eb0 <xQueueGenericSend+0xf0>
80002e50:	c1 b1       	brne	80002e86 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80002e52:	f0 1f 00 12 	mcall	80002e98 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80002e56:	6e e5       	ld.w	r5,r7[0x38]
80002e58:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80002e5a:	f0 1f 00 13 	mcall	80002ea4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80002e5e:	0c 35       	cp.w	r5,r6
80002e60:	c0 d1       	brne	80002e7a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80002e62:	40 2b       	lddsp	r11,sp[0x8]
80002e64:	00 9c       	mov	r12,r0
80002e66:	f0 1f 00 14 	mcall	80002eb4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80002e6a:	0e 9c       	mov	r12,r7
80002e6c:	f0 1f 00 13 	mcall	80002eb8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80002e70:	f0 1f 00 13 	mcall	80002ebc <xQueueGenericSend+0xfc>
80002e74:	cb 41       	brne	80002ddc <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80002e76:	d7 33       	scall
80002e78:	cb 2b       	rjmp	80002ddc <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80002e7a:	0e 9c       	mov	r12,r7
80002e7c:	f0 1f 00 0f 	mcall	80002eb8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80002e80:	f0 1f 00 0f 	mcall	80002ebc <xQueueGenericSend+0xfc>
80002e84:	ca cb       	rjmp	80002ddc <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80002e86:	0e 9c       	mov	r12,r7
80002e88:	f0 1f 00 0c 	mcall	80002eb8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80002e8c:	f0 1f 00 0c 	mcall	80002ebc <xQueueGenericSend+0xfc>
80002e90:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80002e92:	2f bd       	sub	sp,-20
80002e94:	d8 32       	popm	r0-r7,pc
80002e96:	00 00       	add	r0,r0
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	29 20       	sub	r0,-110
80002e9c:	80 00       	ld.sh	r0,r0[0x0]
80002e9e:	2b a0       	sub	r0,-70
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	30 54       	mov	r4,5
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	2a 2c       	sub	r12,-94
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	2f c0       	sub	r0,-4
80002eac:	80 00       	ld.sh	r0,r0[0x0]
80002eae:	2f 34       	sub	r4,-13
80002eb0:	80 00       	ld.sh	r0,r0[0x0]
80002eb2:	2f e4       	sub	r4,-2
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	33 70       	mov	r0,55
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	2c 04       	sub	r4,-64
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	31 e4       	mov	r4,30

80002ec0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80002ec0:	d4 21       	pushm	r4-r7,lr
80002ec2:	18 97       	mov	r7,r12
80002ec4:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80002ec6:	58 0c       	cp.w	r12,0
80002ec8:	c2 f0       	breq	80002f26 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80002eca:	34 cc       	mov	r12,76
80002ecc:	f0 1f 00 17 	mcall	80002f28 <xQueueCreate+0x68>
80002ed0:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80002ed2:	c2 a0       	breq	80002f26 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80002ed4:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80002ed8:	e8 cc ff ff 	sub	r12,r4,-1
80002edc:	f0 1f 00 13 	mcall	80002f28 <xQueueCreate+0x68>
80002ee0:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80002ee2:	c1 e0       	breq	80002f1e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80002ee4:	f8 04 00 04 	add	r4,r12,r4
80002ee8:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80002eea:	30 08       	mov	r8,0
80002eec:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80002eee:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80002ef0:	ee c8 00 01 	sub	r8,r7,1
80002ef4:	ad 38       	mul	r8,r6
80002ef6:	10 0c       	add	r12,r8
80002ef8:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80002efa:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80002efc:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80002f00:	3f f8       	mov	r8,-1
80002f02:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80002f06:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80002f0a:	ea cc ff f0 	sub	r12,r5,-16
80002f0e:	f0 1f 00 08 	mcall	80002f2c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80002f12:	ea cc ff dc 	sub	r12,r5,-36
80002f16:	f0 1f 00 06 	mcall	80002f2c <xQueueCreate+0x6c>
80002f1a:	0a 9c       	mov	r12,r5
80002f1c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80002f1e:	0a 9c       	mov	r12,r5
80002f20:	f0 1f 00 04 	mcall	80002f30 <xQueueCreate+0x70>
80002f24:	d8 2a       	popm	r4-r7,pc,r12=0
80002f26:	d8 2a       	popm	r4-r7,pc,r12=0
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	2b 28       	sub	r8,-78
80002f2c:	80 00       	ld.sh	r0,r0[0x0]
80002f2e:	27 fc       	sub	r12,127
80002f30:	80 00       	ld.sh	r0,r0[0x0]
80002f32:	2b 00       	sub	r0,-80

80002f34 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80002f34:	48 38       	lddpc	r8,80002f40 <vTaskSuspendAll+0xc>
80002f36:	70 09       	ld.w	r9,r8[0x0]
80002f38:	2f f9       	sub	r9,-1
80002f3a:	91 09       	st.w	r8[0x0],r9
}
80002f3c:	5e fc       	retal	r12
80002f3e:	00 00       	add	r0,r0
80002f40:	00 00       	add	r0,r0
80002f42:	07 4c       	ld.w	r12,--r3

80002f44 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80002f44:	49 a8       	lddpc	r8,80002fac <vTaskSwitchContext+0x68>
80002f46:	70 08       	ld.w	r8,r8[0x0]
80002f48:	58 08       	cp.w	r8,0
80002f4a:	c0 b1       	brne	80002f60 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80002f4c:	49 98       	lddpc	r8,80002fb0 <vTaskSwitchContext+0x6c>
80002f4e:	70 08       	ld.w	r8,r8[0x0]
80002f50:	f0 08 00 28 	add	r8,r8,r8<<0x2
80002f54:	49 89       	lddpc	r9,80002fb4 <vTaskSwitchContext+0x70>
80002f56:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80002f5a:	58 08       	cp.w	r8,0
80002f5c:	c0 60       	breq	80002f68 <vTaskSwitchContext+0x24>
80002f5e:	c1 18       	rjmp	80002f80 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80002f60:	30 19       	mov	r9,1
80002f62:	49 68       	lddpc	r8,80002fb8 <vTaskSwitchContext+0x74>
80002f64:	91 09       	st.w	r8[0x0],r9
80002f66:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80002f68:	49 28       	lddpc	r8,80002fb0 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80002f6a:	49 3a       	lddpc	r10,80002fb4 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80002f6c:	70 09       	ld.w	r9,r8[0x0]
80002f6e:	20 19       	sub	r9,1
80002f70:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80002f72:	70 09       	ld.w	r9,r8[0x0]
80002f74:	f2 09 00 29 	add	r9,r9,r9<<0x2
80002f78:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80002f7c:	58 09       	cp.w	r9,0
80002f7e:	cf 70       	breq	80002f6c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80002f80:	48 c8       	lddpc	r8,80002fb0 <vTaskSwitchContext+0x6c>
80002f82:	70 08       	ld.w	r8,r8[0x0]
80002f84:	f0 08 00 28 	add	r8,r8,r8<<0x2
80002f88:	48 b9       	lddpc	r9,80002fb4 <vTaskSwitchContext+0x70>
80002f8a:	f2 08 00 28 	add	r8,r9,r8<<0x2
80002f8e:	70 19       	ld.w	r9,r8[0x4]
80002f90:	72 19       	ld.w	r9,r9[0x4]
80002f92:	91 19       	st.w	r8[0x4],r9
80002f94:	f0 ca ff f8 	sub	r10,r8,-8
80002f98:	14 39       	cp.w	r9,r10
80002f9a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80002f9e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80002fa2:	70 18       	ld.w	r8,r8[0x4]
80002fa4:	70 39       	ld.w	r9,r8[0xc]
80002fa6:	48 68       	lddpc	r8,80002fbc <vTaskSwitchContext+0x78>
80002fa8:	91 09       	st.w	r8[0x0],r9
80002faa:	5e fc       	retal	r12
80002fac:	00 00       	add	r0,r0
80002fae:	07 4c       	ld.w	r12,--r3
80002fb0:	00 00       	add	r0,r0
80002fb2:	07 84       	ld.ub	r4,r3[0x0]
80002fb4:	00 00       	add	r0,r0
80002fb6:	06 68       	and	r8,r3
80002fb8:	00 00       	add	r0,r0
80002fba:	07 6c       	ld.uh	r12,--r3
80002fbc:	00 00       	add	r0,r0
80002fbe:	07 1c       	ld.sh	r12,r3++

80002fc0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80002fc0:	48 48       	lddpc	r8,80002fd0 <vTaskSetTimeOutState+0x10>
80002fc2:	70 08       	ld.w	r8,r8[0x0]
80002fc4:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80002fc6:	48 48       	lddpc	r8,80002fd4 <vTaskSetTimeOutState+0x14>
80002fc8:	70 08       	ld.w	r8,r8[0x0]
80002fca:	99 18       	st.w	r12[0x4],r8
}
80002fcc:	5e fc       	retal	r12
80002fce:	00 00       	add	r0,r0
80002fd0:	00 00       	add	r0,r0
80002fd2:	06 60       	and	r0,r3
80002fd4:	00 00       	add	r0,r0
80002fd6:	07 48       	ld.w	r8,--r3

80002fd8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80002fd8:	30 19       	mov	r9,1
80002fda:	48 28       	lddpc	r8,80002fe0 <vTaskMissedYield+0x8>
80002fdc:	91 09       	st.w	r8[0x0],r9
}
80002fde:	5e fc       	retal	r12
80002fe0:	00 00       	add	r0,r0
80002fe2:	07 6c       	ld.uh	r12,--r3

80002fe4 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80002fe4:	eb cd 40 c0 	pushm	r6-r7,lr
80002fe8:	18 97       	mov	r7,r12
80002fea:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80002fec:	f0 1f 00 15 	mcall	80003040 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80002ff0:	6c 08       	ld.w	r8,r6[0x0]
80002ff2:	5b f8       	cp.w	r8,-1
80002ff4:	c0 31       	brne	80002ffa <xTaskCheckForTimeOut+0x16>
80002ff6:	30 07       	mov	r7,0
80002ff8:	c1 f8       	rjmp	80003036 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80002ffa:	49 39       	lddpc	r9,80003044 <xTaskCheckForTimeOut+0x60>
80002ffc:	72 09       	ld.w	r9,r9[0x0]
80002ffe:	6e 0a       	ld.w	r10,r7[0x0]
80003000:	12 3a       	cp.w	r10,r9
80003002:	c0 70       	breq	80003010 <xTaskCheckForTimeOut+0x2c>
80003004:	49 19       	lddpc	r9,80003048 <xTaskCheckForTimeOut+0x64>
80003006:	72 09       	ld.w	r9,r9[0x0]
80003008:	6e 1a       	ld.w	r10,r7[0x4]
8000300a:	12 3a       	cp.w	r10,r9
8000300c:	e0 88 00 14 	brls	80003034 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80003010:	48 e9       	lddpc	r9,80003048 <xTaskCheckForTimeOut+0x64>
80003012:	72 0a       	ld.w	r10,r9[0x0]
80003014:	6e 19       	ld.w	r9,r7[0x4]
80003016:	12 1a       	sub	r10,r9
80003018:	14 38       	cp.w	r8,r10
8000301a:	e0 88 00 0d 	brls	80003034 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000301e:	48 ba       	lddpc	r10,80003048 <xTaskCheckForTimeOut+0x64>
80003020:	74 0a       	ld.w	r10,r10[0x0]
80003022:	14 19       	sub	r9,r10
80003024:	f2 08 00 08 	add	r8,r9,r8
80003028:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000302a:	0e 9c       	mov	r12,r7
8000302c:	f0 1f 00 08 	mcall	8000304c <xTaskCheckForTimeOut+0x68>
80003030:	30 07       	mov	r7,0
80003032:	c0 28       	rjmp	80003036 <xTaskCheckForTimeOut+0x52>
80003034:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80003036:	f0 1f 00 07 	mcall	80003050 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000303a:	0e 9c       	mov	r12,r7
8000303c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003040:	80 00       	ld.sh	r0,r0[0x0]
80003042:	29 20       	sub	r0,-110
80003044:	00 00       	add	r0,r0
80003046:	06 60       	and	r0,r3
80003048:	00 00       	add	r0,r0
8000304a:	07 48       	ld.w	r8,--r3
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	2f c0       	sub	r0,-4
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	2a 2c       	sub	r12,-94

80003054 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80003054:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80003058:	78 38       	ld.w	r8,r12[0xc]
8000305a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000305c:	ee c6 ff e8 	sub	r6,r7,-24
80003060:	0c 9c       	mov	r12,r6
80003062:	f0 1f 00 15 	mcall	800030b4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003066:	49 58       	lddpc	r8,800030b8 <xTaskRemoveFromEventList+0x64>
80003068:	70 08       	ld.w	r8,r8[0x0]
8000306a:	58 08       	cp.w	r8,0
8000306c:	c1 71       	brne	8000309a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000306e:	ee c6 ff fc 	sub	r6,r7,-4
80003072:	0c 9c       	mov	r12,r6
80003074:	f0 1f 00 10 	mcall	800030b4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80003078:	6e bc       	ld.w	r12,r7[0x2c]
8000307a:	49 18       	lddpc	r8,800030bc <xTaskRemoveFromEventList+0x68>
8000307c:	70 08       	ld.w	r8,r8[0x0]
8000307e:	10 3c       	cp.w	r12,r8
80003080:	e0 88 00 04 	brls	80003088 <xTaskRemoveFromEventList+0x34>
80003084:	48 e8       	lddpc	r8,800030bc <xTaskRemoveFromEventList+0x68>
80003086:	91 0c       	st.w	r8[0x0],r12
80003088:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000308c:	0c 9b       	mov	r11,r6
8000308e:	48 d8       	lddpc	r8,800030c0 <xTaskRemoveFromEventList+0x6c>
80003090:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003094:	f0 1f 00 0c 	mcall	800030c4 <xTaskRemoveFromEventList+0x70>
80003098:	c0 58       	rjmp	800030a2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000309a:	0c 9b       	mov	r11,r6
8000309c:	48 bc       	lddpc	r12,800030c8 <xTaskRemoveFromEventList+0x74>
8000309e:	f0 1f 00 0a 	mcall	800030c4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800030a2:	48 b8       	lddpc	r8,800030cc <xTaskRemoveFromEventList+0x78>
800030a4:	70 08       	ld.w	r8,r8[0x0]
800030a6:	6e b9       	ld.w	r9,r7[0x2c]
800030a8:	70 b8       	ld.w	r8,r8[0x2c]
800030aa:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800030ac:	5f 2c       	srhs	r12
800030ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800030b2:	00 00       	add	r0,r0
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	28 66       	sub	r6,-122
800030b8:	00 00       	add	r0,r0
800030ba:	07 4c       	ld.w	r12,--r3
800030bc:	00 00       	add	r0,r0
800030be:	07 84       	ld.ub	r4,r3[0x0]
800030c0:	00 00       	add	r0,r0
800030c2:	06 68       	and	r8,r3
800030c4:	80 00       	ld.sh	r0,r0[0x0]
800030c6:	28 16       	sub	r6,-127
800030c8:	00 00       	add	r0,r0
800030ca:	07 20       	ld.uh	r0,r3++
800030cc:	00 00       	add	r0,r0
800030ce:	07 1c       	ld.sh	r12,r3++

800030d0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800030d0:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800030d4:	4b 98       	lddpc	r8,800031b8 <vTaskIncrementTick+0xe8>
800030d6:	70 08       	ld.w	r8,r8[0x0]
800030d8:	58 08       	cp.w	r8,0
800030da:	c6 91       	brne	800031ac <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800030dc:	4b 88       	lddpc	r8,800031bc <vTaskIncrementTick+0xec>
800030de:	70 09       	ld.w	r9,r8[0x0]
800030e0:	2f f9       	sub	r9,-1
800030e2:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800030e4:	70 08       	ld.w	r8,r8[0x0]
800030e6:	58 08       	cp.w	r8,0
800030e8:	c1 a1       	brne	8000311c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800030ea:	4b 68       	lddpc	r8,800031c0 <vTaskIncrementTick+0xf0>
800030ec:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800030ee:	4b 69       	lddpc	r9,800031c4 <vTaskIncrementTick+0xf4>
800030f0:	72 0b       	ld.w	r11,r9[0x0]
800030f2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800030f4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800030f6:	4b 59       	lddpc	r9,800031c8 <vTaskIncrementTick+0xf8>
800030f8:	72 0a       	ld.w	r10,r9[0x0]
800030fa:	2f fa       	sub	r10,-1
800030fc:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800030fe:	70 08       	ld.w	r8,r8[0x0]
80003100:	70 08       	ld.w	r8,r8[0x0]
80003102:	58 08       	cp.w	r8,0
80003104:	c0 51       	brne	8000310e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80003106:	3f f9       	mov	r9,-1
80003108:	4b 18       	lddpc	r8,800031cc <vTaskIncrementTick+0xfc>
8000310a:	91 09       	st.w	r8[0x0],r9
8000310c:	c0 88       	rjmp	8000311c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000310e:	4a d8       	lddpc	r8,800031c0 <vTaskIncrementTick+0xf0>
80003110:	70 08       	ld.w	r8,r8[0x0]
80003112:	70 38       	ld.w	r8,r8[0xc]
80003114:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80003116:	70 19       	ld.w	r9,r8[0x4]
80003118:	4a d8       	lddpc	r8,800031cc <vTaskIncrementTick+0xfc>
8000311a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000311c:	4a 88       	lddpc	r8,800031bc <vTaskIncrementTick+0xec>
8000311e:	70 09       	ld.w	r9,r8[0x0]
80003120:	4a b8       	lddpc	r8,800031cc <vTaskIncrementTick+0xfc>
80003122:	70 08       	ld.w	r8,r8[0x0]
80003124:	10 39       	cp.w	r9,r8
80003126:	c4 73       	brcs	800031b4 <vTaskIncrementTick+0xe4>
80003128:	4a 68       	lddpc	r8,800031c0 <vTaskIncrementTick+0xf0>
8000312a:	70 08       	ld.w	r8,r8[0x0]
8000312c:	70 08       	ld.w	r8,r8[0x0]
8000312e:	58 08       	cp.w	r8,0
80003130:	c0 c0       	breq	80003148 <vTaskIncrementTick+0x78>
80003132:	4a 48       	lddpc	r8,800031c0 <vTaskIncrementTick+0xf0>
80003134:	70 08       	ld.w	r8,r8[0x0]
80003136:	70 38       	ld.w	r8,r8[0xc]
80003138:	70 37       	ld.w	r7,r8[0xc]
8000313a:	6e 18       	ld.w	r8,r7[0x4]
8000313c:	4a 09       	lddpc	r9,800031bc <vTaskIncrementTick+0xec>
8000313e:	72 09       	ld.w	r9,r9[0x0]
80003140:	12 38       	cp.w	r8,r9
80003142:	e0 88 00 14 	brls	8000316a <vTaskIncrementTick+0x9a>
80003146:	c0 e8       	rjmp	80003162 <vTaskIncrementTick+0x92>
80003148:	3f f9       	mov	r9,-1
8000314a:	4a 18       	lddpc	r8,800031cc <vTaskIncrementTick+0xfc>
8000314c:	91 09       	st.w	r8[0x0],r9
8000314e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003152:	6a 08       	ld.w	r8,r5[0x0]
80003154:	70 38       	ld.w	r8,r8[0xc]
80003156:	70 37       	ld.w	r7,r8[0xc]
80003158:	6e 18       	ld.w	r8,r7[0x4]
8000315a:	64 09       	ld.w	r9,r2[0x0]
8000315c:	12 38       	cp.w	r8,r9
8000315e:	e0 88 00 0a 	brls	80003172 <vTaskIncrementTick+0xa2>
80003162:	49 b9       	lddpc	r9,800031cc <vTaskIncrementTick+0xfc>
80003164:	93 08       	st.w	r9[0x0],r8
80003166:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000316a:	49 a4       	lddpc	r4,800031d0 <vTaskIncrementTick+0x100>
8000316c:	49 a3       	lddpc	r3,800031d4 <vTaskIncrementTick+0x104>
8000316e:	49 55       	lddpc	r5,800031c0 <vTaskIncrementTick+0xf0>
80003170:	49 32       	lddpc	r2,800031bc <vTaskIncrementTick+0xec>
80003172:	ee c6 ff fc 	sub	r6,r7,-4
80003176:	0c 9c       	mov	r12,r6
80003178:	f0 1f 00 18 	mcall	800031d8 <vTaskIncrementTick+0x108>
8000317c:	6e a8       	ld.w	r8,r7[0x28]
8000317e:	58 08       	cp.w	r8,0
80003180:	c0 50       	breq	8000318a <vTaskIncrementTick+0xba>
80003182:	ee cc ff e8 	sub	r12,r7,-24
80003186:	f0 1f 00 15 	mcall	800031d8 <vTaskIncrementTick+0x108>
8000318a:	6e bc       	ld.w	r12,r7[0x2c]
8000318c:	68 08       	ld.w	r8,r4[0x0]
8000318e:	10 3c       	cp.w	r12,r8
80003190:	e9 fc ba 00 	st.whi	r4[0x0],r12
80003194:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003198:	0c 9b       	mov	r11,r6
8000319a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000319e:	f0 1f 00 10 	mcall	800031dc <vTaskIncrementTick+0x10c>
800031a2:	6a 08       	ld.w	r8,r5[0x0]
800031a4:	70 08       	ld.w	r8,r8[0x0]
800031a6:	58 08       	cp.w	r8,0
800031a8:	cd 51       	brne	80003152 <vTaskIncrementTick+0x82>
800031aa:	cc fb       	rjmp	80003148 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800031ac:	48 d8       	lddpc	r8,800031e0 <vTaskIncrementTick+0x110>
800031ae:	70 09       	ld.w	r9,r8[0x0]
800031b0:	2f f9       	sub	r9,-1
800031b2:	91 09       	st.w	r8[0x0],r9
800031b4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800031b8:	00 00       	add	r0,r0
800031ba:	07 4c       	ld.w	r12,--r3
800031bc:	00 00       	add	r0,r0
800031be:	07 48       	ld.w	r8,--r3
800031c0:	00 00       	add	r0,r0
800031c2:	06 54       	eor	r4,r3
800031c4:	00 00       	add	r0,r0
800031c6:	06 64       	and	r4,r3
800031c8:	00 00       	add	r0,r0
800031ca:	06 60       	and	r0,r3
800031cc:	00 00       	add	r0,r0
800031ce:	00 38       	cp.w	r8,r0
800031d0:	00 00       	add	r0,r0
800031d2:	07 84       	ld.ub	r4,r3[0x0]
800031d4:	00 00       	add	r0,r0
800031d6:	06 68       	and	r8,r3
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	28 66       	sub	r6,-122
800031dc:	80 00       	ld.sh	r0,r0[0x0]
800031de:	28 16       	sub	r6,-127
800031e0:	00 00       	add	r0,r0
800031e2:	06 4c       	or	r12,r3

800031e4 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800031e4:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800031e8:	f0 1f 00 2c 	mcall	80003298 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800031ec:	4a c8       	lddpc	r8,8000329c <xTaskResumeAll+0xb8>
800031ee:	70 09       	ld.w	r9,r8[0x0]
800031f0:	20 19       	sub	r9,1
800031f2:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800031f4:	70 08       	ld.w	r8,r8[0x0]
800031f6:	58 08       	cp.w	r8,0
800031f8:	c4 91       	brne	8000328a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800031fa:	4a a8       	lddpc	r8,800032a0 <xTaskResumeAll+0xbc>
800031fc:	70 08       	ld.w	r8,r8[0x0]
800031fe:	58 08       	cp.w	r8,0
80003200:	c4 50       	breq	8000328a <xTaskResumeAll+0xa6>
80003202:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003204:	4a 85       	lddpc	r5,800032a4 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80003206:	4a 93       	lddpc	r3,800032a8 <xTaskResumeAll+0xc4>
80003208:	4a 92       	lddpc	r2,800032ac <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000320a:	4a a1       	lddpc	r1,800032b0 <xTaskResumeAll+0xcc>
8000320c:	c1 e8       	rjmp	80003248 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000320e:	6a 38       	ld.w	r8,r5[0xc]
80003210:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80003212:	ee cc ff e8 	sub	r12,r7,-24
80003216:	f0 1f 00 28 	mcall	800032b4 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000321a:	ee c6 ff fc 	sub	r6,r7,-4
8000321e:	0c 9c       	mov	r12,r6
80003220:	f0 1f 00 25 	mcall	800032b4 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80003224:	6e bc       	ld.w	r12,r7[0x2c]
80003226:	66 08       	ld.w	r8,r3[0x0]
80003228:	10 3c       	cp.w	r12,r8
8000322a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000322e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003232:	0c 9b       	mov	r11,r6
80003234:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80003238:	f0 1f 00 20 	mcall	800032b8 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000323c:	62 08       	ld.w	r8,r1[0x0]
8000323e:	6e b9       	ld.w	r9,r7[0x2c]
80003240:	70 b8       	ld.w	r8,r8[0x2c]
80003242:	10 39       	cp.w	r9,r8
80003244:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003248:	6a 08       	ld.w	r8,r5[0x0]
8000324a:	58 08       	cp.w	r8,0
8000324c:	ce 11       	brne	8000320e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000324e:	49 c8       	lddpc	r8,800032bc <xTaskResumeAll+0xd8>
80003250:	70 08       	ld.w	r8,r8[0x0]
80003252:	58 08       	cp.w	r8,0
80003254:	c0 f0       	breq	80003272 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003256:	49 a8       	lddpc	r8,800032bc <xTaskResumeAll+0xd8>
80003258:	70 08       	ld.w	r8,r8[0x0]
8000325a:	58 08       	cp.w	r8,0
8000325c:	c1 10       	breq	8000327e <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000325e:	49 87       	lddpc	r7,800032bc <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80003260:	f0 1f 00 18 	mcall	800032c0 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80003264:	6e 08       	ld.w	r8,r7[0x0]
80003266:	20 18       	sub	r8,1
80003268:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000326a:	6e 08       	ld.w	r8,r7[0x0]
8000326c:	58 08       	cp.w	r8,0
8000326e:	cf 91       	brne	80003260 <xTaskResumeAll+0x7c>
80003270:	c0 78       	rjmp	8000327e <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80003272:	58 14       	cp.w	r4,1
80003274:	c0 50       	breq	8000327e <xTaskResumeAll+0x9a>
80003276:	49 48       	lddpc	r8,800032c4 <xTaskResumeAll+0xe0>
80003278:	70 08       	ld.w	r8,r8[0x0]
8000327a:	58 18       	cp.w	r8,1
8000327c:	c0 71       	brne	8000328a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000327e:	30 09       	mov	r9,0
80003280:	49 18       	lddpc	r8,800032c4 <xTaskResumeAll+0xe0>
80003282:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80003284:	d7 33       	scall
80003286:	30 17       	mov	r7,1
80003288:	c0 28       	rjmp	8000328c <xTaskResumeAll+0xa8>
8000328a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000328c:	f0 1f 00 0f 	mcall	800032c8 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80003290:	0e 9c       	mov	r12,r7
80003292:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80003296:	00 00       	add	r0,r0
80003298:	80 00       	ld.sh	r0,r0[0x0]
8000329a:	29 20       	sub	r0,-110
8000329c:	00 00       	add	r0,r0
8000329e:	07 4c       	ld.w	r12,--r3
800032a0:	00 00       	add	r0,r0
800032a2:	07 68       	ld.uh	r8,--r3
800032a4:	00 00       	add	r0,r0
800032a6:	07 20       	ld.uh	r0,r3++
800032a8:	00 00       	add	r0,r0
800032aa:	07 84       	ld.ub	r4,r3[0x0]
800032ac:	00 00       	add	r0,r0
800032ae:	06 68       	and	r8,r3
800032b0:	00 00       	add	r0,r0
800032b2:	07 1c       	ld.sh	r12,r3++
800032b4:	80 00       	ld.sh	r0,r0[0x0]
800032b6:	28 66       	sub	r6,-122
800032b8:	80 00       	ld.sh	r0,r0[0x0]
800032ba:	28 16       	sub	r6,-127
800032bc:	00 00       	add	r0,r0
800032be:	06 4c       	or	r12,r3
800032c0:	80 00       	ld.sh	r0,r0[0x0]
800032c2:	30 d0       	mov	r0,13
800032c4:	00 00       	add	r0,r0
800032c6:	07 6c       	ld.uh	r12,--r3
800032c8:	80 00       	ld.sh	r0,r0[0x0]
800032ca:	2a 2c       	sub	r12,-94

800032cc <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800032cc:	eb cd 40 80 	pushm	r7,lr
800032d0:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800032d2:	49 08       	lddpc	r8,80003310 <prvAddCurrentTaskToDelayedList+0x44>
800032d4:	70 08       	ld.w	r8,r8[0x0]
800032d6:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800032d8:	48 f8       	lddpc	r8,80003314 <prvAddCurrentTaskToDelayedList+0x48>
800032da:	70 08       	ld.w	r8,r8[0x0]
800032dc:	10 3c       	cp.w	r12,r8
800032de:	c0 a2       	brcc	800032f2 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800032e0:	48 c8       	lddpc	r8,80003310 <prvAddCurrentTaskToDelayedList+0x44>
800032e2:	70 0b       	ld.w	r11,r8[0x0]
800032e4:	48 d8       	lddpc	r8,80003318 <prvAddCurrentTaskToDelayedList+0x4c>
800032e6:	70 0c       	ld.w	r12,r8[0x0]
800032e8:	2f cb       	sub	r11,-4
800032ea:	f0 1f 00 0d 	mcall	8000331c <prvAddCurrentTaskToDelayedList+0x50>
800032ee:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800032f2:	48 88       	lddpc	r8,80003310 <prvAddCurrentTaskToDelayedList+0x44>
800032f4:	70 0b       	ld.w	r11,r8[0x0]
800032f6:	48 b8       	lddpc	r8,80003320 <prvAddCurrentTaskToDelayedList+0x54>
800032f8:	70 0c       	ld.w	r12,r8[0x0]
800032fa:	2f cb       	sub	r11,-4
800032fc:	f0 1f 00 08 	mcall	8000331c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80003300:	48 98       	lddpc	r8,80003324 <prvAddCurrentTaskToDelayedList+0x58>
80003302:	70 08       	ld.w	r8,r8[0x0]
80003304:	10 37       	cp.w	r7,r8
80003306:	c0 32       	brcc	8000330c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80003308:	48 78       	lddpc	r8,80003324 <prvAddCurrentTaskToDelayedList+0x58>
8000330a:	91 07       	st.w	r8[0x0],r7
8000330c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003310:	00 00       	add	r0,r0
80003312:	07 1c       	ld.sh	r12,r3++
80003314:	00 00       	add	r0,r0
80003316:	07 48       	ld.w	r8,--r3
80003318:	00 00       	add	r0,r0
8000331a:	06 64       	and	r4,r3
8000331c:	80 00       	ld.sh	r0,r0[0x0]
8000331e:	28 32       	sub	r2,-125
80003320:	00 00       	add	r0,r0
80003322:	06 54       	eor	r4,r3
80003324:	00 00       	add	r0,r0
80003326:	00 38       	cp.w	r8,r0

80003328 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80003328:	eb cd 40 c0 	pushm	r6-r7,lr
8000332c:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
8000332e:	58 0c       	cp.w	r12,0
80003330:	c1 10       	breq	80003352 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80003332:	f0 1f 00 0a 	mcall	80003358 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80003336:	48 a8       	lddpc	r8,8000335c <vTaskDelay+0x34>
80003338:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000333a:	48 a8       	lddpc	r8,80003360 <vTaskDelay+0x38>
8000333c:	70 0c       	ld.w	r12,r8[0x0]
8000333e:	2f cc       	sub	r12,-4
80003340:	f0 1f 00 09 	mcall	80003364 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80003344:	ee 06 00 0c 	add	r12,r7,r6
80003348:	f0 1f 00 08 	mcall	80003368 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
8000334c:	f0 1f 00 08 	mcall	8000336c <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80003350:	c0 21       	brne	80003354 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80003352:	d7 33       	scall
80003354:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003358:	80 00       	ld.sh	r0,r0[0x0]
8000335a:	2f 34       	sub	r4,-13
8000335c:	00 00       	add	r0,r0
8000335e:	07 48       	ld.w	r8,--r3
80003360:	00 00       	add	r0,r0
80003362:	07 1c       	ld.sh	r12,r3++
80003364:	80 00       	ld.sh	r0,r0[0x0]
80003366:	28 66       	sub	r6,-122
80003368:	80 00       	ld.sh	r0,r0[0x0]
8000336a:	32 cc       	mov	r12,44
8000336c:	80 00       	ld.sh	r0,r0[0x0]
8000336e:	31 e4       	mov	r4,30

80003370 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80003370:	eb cd 40 c0 	pushm	r6-r7,lr
80003374:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80003376:	48 e7       	lddpc	r7,800033ac <vTaskPlaceOnEventList+0x3c>
80003378:	6e 0b       	ld.w	r11,r7[0x0]
8000337a:	2e 8b       	sub	r11,-24
8000337c:	f0 1f 00 0d 	mcall	800033b0 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80003380:	6e 0c       	ld.w	r12,r7[0x0]
80003382:	2f cc       	sub	r12,-4
80003384:	f0 1f 00 0c 	mcall	800033b4 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80003388:	5b f6       	cp.w	r6,-1
8000338a:	c0 81       	brne	8000339a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000338c:	6e 0b       	ld.w	r11,r7[0x0]
8000338e:	2f cb       	sub	r11,-4
80003390:	48 ac       	lddpc	r12,800033b8 <vTaskPlaceOnEventList+0x48>
80003392:	f0 1f 00 0b 	mcall	800033bc <vTaskPlaceOnEventList+0x4c>
80003396:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000339a:	48 a8       	lddpc	r8,800033c0 <vTaskPlaceOnEventList+0x50>
8000339c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000339e:	ec 0c 00 0c 	add	r12,r6,r12
800033a2:	f0 1f 00 09 	mcall	800033c4 <vTaskPlaceOnEventList+0x54>
800033a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800033aa:	00 00       	add	r0,r0
800033ac:	00 00       	add	r0,r0
800033ae:	07 1c       	ld.sh	r12,r3++
800033b0:	80 00       	ld.sh	r0,r0[0x0]
800033b2:	28 32       	sub	r2,-125
800033b4:	80 00       	ld.sh	r0,r0[0x0]
800033b6:	28 66       	sub	r6,-122
800033b8:	00 00       	add	r0,r0
800033ba:	07 70       	ld.ub	r0,--r3
800033bc:	80 00       	ld.sh	r0,r0[0x0]
800033be:	28 16       	sub	r6,-127
800033c0:	00 00       	add	r0,r0
800033c2:	07 48       	ld.w	r8,--r3
800033c4:	80 00       	ld.sh	r0,r0[0x0]
800033c6:	32 cc       	mov	r12,44

800033c8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800033c8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800033cc:	49 57       	lddpc	r7,80003420 <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800033ce:	49 64       	lddpc	r4,80003424 <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800033d0:	49 63       	lddpc	r3,80003428 <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800033d2:	49 75       	lddpc	r5,8000342c <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800033d4:	6e 08       	ld.w	r8,r7[0x0]
800033d6:	58 08       	cp.w	r8,0
800033d8:	c1 e0       	breq	80003414 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800033da:	f0 1f 00 16 	mcall	80003430 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800033de:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800033e0:	f0 1f 00 15 	mcall	80003434 <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
800033e4:	58 06       	cp.w	r6,0
800033e6:	c1 70       	breq	80003414 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800033e8:	f0 1f 00 14 	mcall	80003438 <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800033ec:	68 38       	ld.w	r8,r4[0xc]
800033ee:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800033f0:	ec cc ff fc 	sub	r12,r6,-4
800033f4:	f0 1f 00 12 	mcall	8000343c <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
800033f8:	66 08       	ld.w	r8,r3[0x0]
800033fa:	20 18       	sub	r8,1
800033fc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800033fe:	6e 08       	ld.w	r8,r7[0x0]
80003400:	20 18       	sub	r8,1
80003402:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80003404:	f0 1f 00 0f 	mcall	80003440 <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80003408:	6c cc       	ld.w	r12,r6[0x30]
8000340a:	f0 1f 00 0f 	mcall	80003444 <prvIdleTask+0x7c>
		vPortFree( pxTCB );
8000340e:	0c 9c       	mov	r12,r6
80003410:	f0 1f 00 0d 	mcall	80003444 <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80003414:	6a 08       	ld.w	r8,r5[0x0]
80003416:	58 18       	cp.w	r8,1
80003418:	fe 98 ff de 	brls	800033d4 <prvIdleTask+0xc>
			{
				taskYIELD();
8000341c:	d7 33       	scall
8000341e:	cd bb       	rjmp	800033d4 <prvIdleTask+0xc>
80003420:	00 00       	add	r0,r0
80003422:	06 5c       	eor	r12,r3
80003424:	00 00       	add	r0,r0
80003426:	07 08       	ld.w	r8,r3++
80003428:	00 00       	add	r0,r0
8000342a:	07 68       	ld.uh	r8,--r3
8000342c:	00 00       	add	r0,r0
8000342e:	06 68       	and	r8,r3
80003430:	80 00       	ld.sh	r0,r0[0x0]
80003432:	2f 34       	sub	r4,-13
80003434:	80 00       	ld.sh	r0,r0[0x0]
80003436:	31 e4       	mov	r4,30
80003438:	80 00       	ld.sh	r0,r0[0x0]
8000343a:	29 20       	sub	r0,-110
8000343c:	80 00       	ld.sh	r0,r0[0x0]
8000343e:	28 66       	sub	r6,-122
80003440:	80 00       	ld.sh	r0,r0[0x0]
80003442:	2a 2c       	sub	r12,-94
80003444:	80 00       	ld.sh	r0,r0[0x0]
80003446:	2b 00       	sub	r0,-80

80003448 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80003448:	d4 31       	pushm	r0-r7,lr
8000344a:	20 1d       	sub	sp,4
8000344c:	fa c4 ff d8 	sub	r4,sp,-40
80003450:	50 0c       	stdsp	sp[0x0],r12
80003452:	16 91       	mov	r1,r11
80003454:	14 97       	mov	r7,r10
80003456:	12 90       	mov	r0,r9
80003458:	10 93       	mov	r3,r8
8000345a:	68 02       	ld.w	r2,r4[0x0]
8000345c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000345e:	34 4c       	mov	r12,68
80003460:	f0 1f 00 5b 	mcall	800035cc <xTaskGenericCreate+0x184>
80003464:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80003466:	c0 31       	brne	8000346c <xTaskGenericCreate+0x24>
80003468:	3f fc       	mov	r12,-1
8000346a:	ca d8       	rjmp	800035c4 <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000346c:	58 06       	cp.w	r6,0
8000346e:	e0 81 00 ad 	brne	800035c8 <xTaskGenericCreate+0x180>
80003472:	0e 9c       	mov	r12,r7
80003474:	5c 7c       	castu.h	r12
80003476:	a3 6c       	lsl	r12,0x2
80003478:	f0 1f 00 55 	mcall	800035cc <xTaskGenericCreate+0x184>
8000347c:	18 96       	mov	r6,r12
8000347e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80003480:	c0 61       	brne	8000348c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80003482:	0a 9c       	mov	r12,r5
80003484:	f0 1f 00 53 	mcall	800035d0 <xTaskGenericCreate+0x188>
80003488:	3f fc       	mov	r12,-1
8000348a:	c9 d8       	rjmp	800035c4 <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000348c:	5c 77       	castu.h	r7
8000348e:	ee 0a 15 02 	lsl	r10,r7,0x2
80003492:	e0 6b 00 a5 	mov	r11,165
80003496:	0c 9c       	mov	r12,r6
80003498:	f0 1f 00 4f 	mcall	800035d4 <xTaskGenericCreate+0x18c>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
8000349c:	ee c6 00 01 	sub	r6,r7,1
800034a0:	6a c8       	ld.w	r8,r5[0x30]
800034a2:	f0 06 00 26 	add	r6,r8,r6<<0x2
800034a6:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800034aa:	31 0a       	mov	r10,16
800034ac:	02 9b       	mov	r11,r1
800034ae:	ea cc ff cc 	sub	r12,r5,-52
800034b2:	f0 1f 00 4a 	mcall	800035d8 <xTaskGenericCreate+0x190>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800034b6:	30 08       	mov	r8,0
800034b8:	eb 68 00 43 	st.b	r5[67],r8
800034bc:	58 73       	cp.w	r3,7
800034be:	e6 07 17 80 	movls	r7,r3
800034c2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800034c6:	8b b7       	st.w	r5[0x2c],r7
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800034c8:	ea c4 ff fc 	sub	r4,r5,-4
800034cc:	08 9c       	mov	r12,r4
800034ce:	f0 1f 00 44 	mcall	800035dc <xTaskGenericCreate+0x194>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800034d2:	ea cc ff e8 	sub	r12,r5,-24
800034d6:	f0 1f 00 42 	mcall	800035dc <xTaskGenericCreate+0x194>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800034da:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800034dc:	ee 07 11 08 	rsub	r7,r7,8
800034e0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800034e2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800034e4:	00 9a       	mov	r10,r0
800034e6:	40 0b       	lddsp	r11,sp[0x0]
800034e8:	0c 9c       	mov	r12,r6
800034ea:	f0 1f 00 3e 	mcall	800035e0 <xTaskGenericCreate+0x198>
800034ee:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800034f0:	58 02       	cp.w	r2,0
800034f2:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800034f6:	f0 1f 00 3c 	mcall	800035e4 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
800034fa:	4b c8       	lddpc	r8,800035e8 <xTaskGenericCreate+0x1a0>
800034fc:	70 09       	ld.w	r9,r8[0x0]
800034fe:	2f f9       	sub	r9,-1
80003500:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80003502:	4b b8       	lddpc	r8,800035ec <xTaskGenericCreate+0x1a4>
80003504:	70 08       	ld.w	r8,r8[0x0]
80003506:	58 08       	cp.w	r8,0
80003508:	c2 61       	brne	80003554 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000350a:	4b 98       	lddpc	r8,800035ec <xTaskGenericCreate+0x1a4>
8000350c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000350e:	4b 78       	lddpc	r8,800035e8 <xTaskGenericCreate+0x1a0>
80003510:	70 08       	ld.w	r8,r8[0x0]
80003512:	58 18       	cp.w	r8,1
80003514:	c2 b1       	brne	8000356a <xTaskGenericCreate+0x122>
80003516:	4b 77       	lddpc	r7,800035f0 <xTaskGenericCreate+0x1a8>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80003518:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000351c:	0e 9c       	mov	r12,r7
8000351e:	f0 1f 00 36 	mcall	800035f4 <xTaskGenericCreate+0x1ac>
80003522:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80003524:	0c 37       	cp.w	r7,r6
80003526:	cf b1       	brne	8000351c <xTaskGenericCreate+0xd4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80003528:	4b 47       	lddpc	r7,800035f8 <xTaskGenericCreate+0x1b0>
8000352a:	0e 9c       	mov	r12,r7
8000352c:	f0 1f 00 32 	mcall	800035f4 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80003530:	4b 36       	lddpc	r6,800035fc <xTaskGenericCreate+0x1b4>
80003532:	0c 9c       	mov	r12,r6
80003534:	f0 1f 00 30 	mcall	800035f4 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xPendingReadyList );
80003538:	4b 2c       	lddpc	r12,80003600 <xTaskGenericCreate+0x1b8>
8000353a:	f0 1f 00 2f 	mcall	800035f4 <xTaskGenericCreate+0x1ac>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000353e:	4b 2c       	lddpc	r12,80003604 <xTaskGenericCreate+0x1bc>
80003540:	f0 1f 00 2d 	mcall	800035f4 <xTaskGenericCreate+0x1ac>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80003544:	4b 1c       	lddpc	r12,80003608 <xTaskGenericCreate+0x1c0>
80003546:	f0 1f 00 2c 	mcall	800035f4 <xTaskGenericCreate+0x1ac>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000354a:	4b 18       	lddpc	r8,8000360c <xTaskGenericCreate+0x1c4>
8000354c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000354e:	4b 18       	lddpc	r8,80003610 <xTaskGenericCreate+0x1c8>
80003550:	91 06       	st.w	r8[0x0],r6
80003552:	c0 c8       	rjmp	8000356a <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80003554:	4b 08       	lddpc	r8,80003614 <xTaskGenericCreate+0x1cc>
80003556:	70 08       	ld.w	r8,r8[0x0]
80003558:	58 08       	cp.w	r8,0
8000355a:	c0 81       	brne	8000356a <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000355c:	4a 48       	lddpc	r8,800035ec <xTaskGenericCreate+0x1a4>
8000355e:	70 08       	ld.w	r8,r8[0x0]
80003560:	70 b8       	ld.w	r8,r8[0x2c]
80003562:	10 33       	cp.w	r3,r8
80003564:	c0 33       	brcs	8000356a <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
80003566:	4a 28       	lddpc	r8,800035ec <xTaskGenericCreate+0x1a4>
80003568:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000356a:	6a b8       	ld.w	r8,r5[0x2c]
8000356c:	4a b9       	lddpc	r9,80003618 <xTaskGenericCreate+0x1d0>
8000356e:	72 09       	ld.w	r9,r9[0x0]
80003570:	12 38       	cp.w	r8,r9
80003572:	e0 88 00 04 	brls	8000357a <xTaskGenericCreate+0x132>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80003576:	4a 99       	lddpc	r9,80003618 <xTaskGenericCreate+0x1d0>
80003578:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000357a:	4a 98       	lddpc	r8,8000361c <xTaskGenericCreate+0x1d4>
8000357c:	70 09       	ld.w	r9,r8[0x0]
8000357e:	2f f9       	sub	r9,-1
80003580:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80003582:	6a b8       	ld.w	r8,r5[0x2c]
80003584:	4a 79       	lddpc	r9,80003620 <xTaskGenericCreate+0x1d8>
80003586:	72 09       	ld.w	r9,r9[0x0]
80003588:	12 38       	cp.w	r8,r9
8000358a:	e0 88 00 04 	brls	80003592 <xTaskGenericCreate+0x14a>
8000358e:	4a 59       	lddpc	r9,80003620 <xTaskGenericCreate+0x1d8>
80003590:	93 08       	st.w	r9[0x0],r8
80003592:	6a bc       	ld.w	r12,r5[0x2c]
80003594:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003598:	08 9b       	mov	r11,r4
8000359a:	49 68       	lddpc	r8,800035f0 <xTaskGenericCreate+0x1a8>
8000359c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800035a0:	f0 1f 00 21 	mcall	80003624 <xTaskGenericCreate+0x1dc>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800035a4:	f0 1f 00 21 	mcall	80003628 <xTaskGenericCreate+0x1e0>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800035a8:	49 b8       	lddpc	r8,80003614 <xTaskGenericCreate+0x1cc>
800035aa:	70 08       	ld.w	r8,r8[0x0]
800035ac:	58 08       	cp.w	r8,0
800035ae:	c0 a0       	breq	800035c2 <xTaskGenericCreate+0x17a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800035b0:	48 f8       	lddpc	r8,800035ec <xTaskGenericCreate+0x1a4>
800035b2:	70 08       	ld.w	r8,r8[0x0]
800035b4:	70 b8       	ld.w	r8,r8[0x2c]
800035b6:	10 33       	cp.w	r3,r8
800035b8:	e0 88 00 05 	brls	800035c2 <xTaskGenericCreate+0x17a>
			{
				portYIELD_WITHIN_API();
800035bc:	d7 33       	scall
800035be:	30 1c       	mov	r12,1
800035c0:	c0 28       	rjmp	800035c4 <xTaskGenericCreate+0x17c>
800035c2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800035c4:	2f fd       	sub	sp,-4
800035c6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800035c8:	99 c6       	st.w	r12[0x30],r6
800035ca:	c6 1b       	rjmp	8000348c <xTaskGenericCreate+0x44>
800035cc:	80 00       	ld.sh	r0,r0[0x0]
800035ce:	2b 28       	sub	r8,-78
800035d0:	80 00       	ld.sh	r0,r0[0x0]
800035d2:	2b 00       	sub	r0,-80
800035d4:	80 00       	ld.sh	r0,r0[0x0]
800035d6:	40 98       	lddsp	r8,sp[0x24]
800035d8:	80 00       	ld.sh	r0,r0[0x0]
800035da:	40 c8       	lddsp	r8,sp[0x30]
800035dc:	80 00       	ld.sh	r0,r0[0x0]
800035de:	28 10       	sub	r0,-127
800035e0:	80 00       	ld.sh	r0,r0[0x0]
800035e2:	28 8c       	sub	r12,-120
800035e4:	80 00       	ld.sh	r0,r0[0x0]
800035e6:	29 20       	sub	r0,-110
800035e8:	00 00       	add	r0,r0
800035ea:	07 68       	ld.uh	r8,--r3
800035ec:	00 00       	add	r0,r0
800035ee:	07 1c       	ld.sh	r12,r3++
800035f0:	00 00       	add	r0,r0
800035f2:	06 68       	and	r8,r3
800035f4:	80 00       	ld.sh	r0,r0[0x0]
800035f6:	27 fc       	sub	r12,127
800035f8:	00 00       	add	r0,r0
800035fa:	07 34       	ld.ub	r4,r3++
800035fc:	00 00       	add	r0,r0
800035fe:	07 50       	ld.sh	r0,--r3
80003600:	00 00       	add	r0,r0
80003602:	07 20       	ld.uh	r0,r3++
80003604:	00 00       	add	r0,r0
80003606:	07 08       	ld.w	r8,r3++
80003608:	00 00       	add	r0,r0
8000360a:	07 70       	ld.ub	r0,--r3
8000360c:	00 00       	add	r0,r0
8000360e:	06 54       	eor	r4,r3
80003610:	00 00       	add	r0,r0
80003612:	06 64       	and	r4,r3
80003614:	00 00       	add	r0,r0
80003616:	06 58       	eor	r8,r3
80003618:	00 00       	add	r0,r0
8000361a:	06 50       	eor	r0,r3
8000361c:	00 00       	add	r0,r0
8000361e:	07 64       	ld.uh	r4,--r3
80003620:	00 00       	add	r0,r0
80003622:	07 84       	ld.ub	r4,r3[0x0]
80003624:	80 00       	ld.sh	r0,r0[0x0]
80003626:	28 16       	sub	r6,-127
80003628:	80 00       	ld.sh	r0,r0[0x0]
8000362a:	2a 2c       	sub	r12,-94

8000362c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000362c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000362e:	30 09       	mov	r9,0
80003630:	1a d9       	st.w	--sp,r9
80003632:	1a d9       	st.w	--sp,r9
80003634:	1a d9       	st.w	--sp,r9
80003636:	12 98       	mov	r8,r9
80003638:	e0 6a 01 00 	mov	r10,256
8000363c:	48 9b       	lddpc	r11,80003660 <vTaskStartScheduler+0x34>
8000363e:	48 ac       	lddpc	r12,80003664 <vTaskStartScheduler+0x38>
80003640:	f0 1f 00 0a 	mcall	80003668 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80003644:	2f dd       	sub	sp,-12
80003646:	58 1c       	cp.w	r12,1
80003648:	c0 a1       	brne	8000365c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000364a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000364c:	30 19       	mov	r9,1
8000364e:	48 88       	lddpc	r8,8000366c <vTaskStartScheduler+0x40>
80003650:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80003652:	30 09       	mov	r9,0
80003654:	48 78       	lddpc	r8,80003670 <vTaskStartScheduler+0x44>
80003656:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80003658:	f0 1f 00 07 	mcall	80003674 <vTaskStartScheduler+0x48>
8000365c:	d8 02       	popm	pc
8000365e:	00 00       	add	r0,r0
80003660:	80 00       	ld.sh	r0,r0[0x0]
80003662:	48 f8       	lddpc	r8,8000369c <__avr32_f32_div+0x24>
80003664:	80 00       	ld.sh	r0,r0[0x0]
80003666:	33 c8       	mov	r8,60
80003668:	80 00       	ld.sh	r0,r0[0x0]
8000366a:	34 48       	mov	r8,68
8000366c:	00 00       	add	r0,r0
8000366e:	06 58       	eor	r8,r3
80003670:	00 00       	add	r0,r0
80003672:	07 48       	ld.w	r8,--r3
80003674:	80 00       	ld.sh	r0,r0[0x0]
80003676:	29 30       	sub	r0,-109

80003678 <__avr32_f32_div>:
80003678:	f7 ec 20 08 	eor	r8,r11,r12
8000367c:	a1 7c       	lsl	r12,0x1
8000367e:	a1 7b       	lsl	r11,0x1
80003680:	c7 a0       	breq	80003774 <__divsf_return_op1+0x16>
80003682:	18 7c       	tst	r12,r12
80003684:	f9 b9 00 00 	moveq	r9,0
80003688:	c0 90       	breq	8000369a <__avr32_f32_div+0x22>
8000368a:	f8 09 16 18 	lsr	r9,r12,0x18
8000368e:	c7 e0       	breq	8000378a <__divsf_return_op1+0x2c>
80003690:	e0 49 00 ff 	cp.w	r9,255
80003694:	c6 82       	brcc	80003764 <__divsf_return_op1+0x6>
80003696:	a7 7c       	lsl	r12,0x7
80003698:	bf bc       	sbr	r12,0x1f
8000369a:	f6 0a 16 18 	lsr	r10,r11,0x18
8000369e:	c7 e0       	breq	8000379a <__divsf_return_op1+0x3c>
800036a0:	e0 4a 00 ff 	cp.w	r10,255
800036a4:	c6 62       	brcc	80003770 <__divsf_return_op1+0x12>
800036a6:	a7 7b       	lsl	r11,0x7
800036a8:	bf bb       	sbr	r11,0x1f
800036aa:	58 09       	cp.w	r9,0
800036ac:	f5 bc 00 00 	subfeq	r12,0
800036b0:	5e 0d       	reteq	0
800036b2:	1a d5       	st.w	--sp,r5
800036b4:	bb 27       	st.d	--sp,r6
800036b6:	14 19       	sub	r9,r10
800036b8:	28 19       	sub	r9,-127
800036ba:	fc 1a 80 00 	movh	r10,0x8000
800036be:	a3 8c       	lsr	r12,0x2
800036c0:	f6 05 16 02 	lsr	r5,r11,0x2
800036c4:	f4 0b 16 01 	lsr	r11,r10,0x1
800036c8:	ed d5 c3 62 	bfextu	r6,r5,0x1b,0x2
800036cc:	5c d6       	com	r6
800036ce:	f7 d6 d3 82 	bfins	r11,r6,0x1c,0x2
800036d2:	f6 05 06 46 	mulu.d	r6,r11,r5
800036d6:	f4 07 01 27 	sub	r7,r10,r7<<0x2
800036da:	f6 07 06 46 	mulu.d	r6,r11,r7
800036de:	ee 0b 15 02 	lsl	r11,r7,0x2
800036e2:	f6 05 06 46 	mulu.d	r6,r11,r5
800036e6:	f4 07 01 27 	sub	r7,r10,r7<<0x2
800036ea:	f6 07 06 46 	mulu.d	r6,r11,r7
800036ee:	ee 0b 15 02 	lsl	r11,r7,0x2
800036f2:	f6 05 06 46 	mulu.d	r6,r11,r5
800036f6:	f4 07 01 27 	sub	r7,r10,r7<<0x2
800036fa:	f6 07 06 46 	mulu.d	r6,r11,r7
800036fe:	ee 0b 15 02 	lsl	r11,r7,0x2
80003702:	f6 05 06 46 	mulu.d	r6,r11,r5
80003706:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000370a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000370e:	ee 0b 15 02 	lsl	r11,r7,0x2
80003712:	f6 0c 06 46 	mulu.d	r6,r11,r12
80003716:	a5 8c       	lsr	r12,0x4
80003718:	ed b7 00 1c 	bld	r7,0x1c
8000371c:	c0 40       	breq	80003724 <__avr32_f32_div+0xac>
8000371e:	a1 77       	lsl	r7,0x1
80003720:	20 19       	sub	r9,1
80003722:	a1 7c       	lsl	r12,0x1
80003724:	58 09       	cp.w	r9,0
80003726:	e0 8a 00 42 	brle	800037aa <__avr32_f32_div_res_subnormal>
8000372a:	e0 17 ff e0 	andl	r7,0xffe0
8000372e:	e8 17 00 10 	orl	r7,0x10
80003732:	ea 07 06 4a 	mulu.d	r10,r5,r7
80003736:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
8000373a:	58 0a       	cp.w	r10,0

8000373c <__avr32_f32_div_round_subnormal>:
8000373c:	f8 0b 13 00 	cpc	r11,r12
80003740:	5f 3b       	srlo	r11
80003742:	ea 0b 17 00 	moveq	r11,r5
80003746:	ee 0c 16 05 	lsr	r12,r7,0x5
8000374a:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8
8000374e:	bb 07       	ld.d	r6,sp++
80003750:	1b 05       	ld.w	r5,sp++
80003752:	ed b8 00 1f 	bld	r8,0x1f
80003756:	ef bc 00 1f 	bst	r12,0x1f
8000375a:	16 0c       	add	r12,r11
8000375c:	5e fc       	retal	r12

8000375e <__divsf_return_op1>:
8000375e:	a1 78       	lsl	r8,0x1
80003760:	5d 0c       	ror	r12
80003762:	5e fc       	retal	r12
80003764:	5e 1e       	retne	-1
80003766:	fc 19 ff 00 	movh	r9,0xff00
8000376a:	12 3b       	cp.w	r11,r9
8000376c:	cf 93       	brcs	8000375e <__divsf_return_op1>
8000376e:	5e fe       	retal	-1
80003770:	5e 0d       	reteq	0
80003772:	5e fe       	retal	-1
80003774:	18 7c       	tst	r12,r12
80003776:	5e 0e       	reteq	-1
80003778:	f8 09 16 18 	lsr	r9,r12,0x18
8000377c:	c0 70       	breq	8000378a <__divsf_return_op1+0x2c>
8000377e:	e0 49 00 ff 	cp.w	r9,255
80003782:	cf 12       	brcc	80003764 <__divsf_return_op1+0x6>
80003784:	fc 1c ff 00 	movh	r12,0xff00
80003788:	ce bb       	rjmp	8000375e <__divsf_return_op1>
8000378a:	a7 7c       	lsl	r12,0x7
8000378c:	f8 09 12 00 	clz	r9,r12
80003790:	f8 09 09 4c 	lsl	r12,r12,r9
80003794:	f2 09 11 01 	rsub	r9,r9,1
80003798:	c8 1b       	rjmp	8000369a <__avr32_f32_div+0x22>
8000379a:	a7 7b       	lsl	r11,0x7
8000379c:	f6 0a 12 00 	clz	r10,r11
800037a0:	f6 0a 09 4b 	lsl	r11,r11,r10
800037a4:	f4 0a 11 01 	rsub	r10,r10,1
800037a8:	c8 5b       	rjmp	800036b2 <__avr32_f32_div+0x3a>

800037aa <__avr32_f32_div_res_subnormal>:
800037aa:	5c 39       	neg	r9
800037ac:	2f f9       	sub	r9,-1
800037ae:	f1 b9 04 a0 	satu	r9,0x5
800037b2:	f2 0a 11 20 	rsub	r10,r9,32
800037b6:	ee 09 0a 47 	lsr	r7,r7,r9
800037ba:	f8 0a 09 46 	lsl	r6,r12,r10
800037be:	f8 09 0a 4c 	lsr	r12,r12,r9
800037c2:	e0 17 ff e0 	andl	r7,0xffe0
800037c6:	e8 17 00 10 	orl	r7,0x10
800037ca:	ea 07 06 4a 	mulu.d	r10,r5,r7
800037ce:	30 09       	mov	r9,0
800037d0:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
800037d4:	0c 3a       	cp.w	r10,r6
800037d6:	cb 3b       	rjmp	8000373c <__avr32_f32_div_round_subnormal>

800037d8 <__avr32_f32_sub_from_add>:
800037d8:	ee 1b 80 00 	eorh	r11,0x8000

800037dc <__avr32_f32_sub>:
800037dc:	f7 ec 20 08 	eor	r8,r11,r12
800037e0:	c6 46       	brmi	800038a8 <__avr32_f32_add_from_sub>
800037e2:	18 98       	mov	r8,r12
800037e4:	e6 1c 80 00 	andh	r12,0x8000,COH
800037e8:	bf db       	cbr	r11,0x1f
800037ea:	bf d8       	cbr	r8,0x1f
800037ec:	f0 0b 0c 4a 	max	r10,r8,r11
800037f0:	f0 0b 0d 49 	min	r9,r8,r11
800037f4:	10 3a       	cp.w	r10,r8
800037f6:	f7 bc 01 01 	subne	r12,1
800037fa:	e6 1c 80 00 	andh	r12,0x8000,COH
800037fe:	f4 08 15 08 	lsl	r8,r10,0x8
80003802:	bf b8       	sbr	r8,0x1f
80003804:	b7 9a       	lsr	r10,0x17
80003806:	e0 4a 00 ff 	cp.w	r10,255
8000380a:	c3 80       	breq	8000387a <__avr32_f32_sub_op1_nan_or_inf>
8000380c:	f2 0b 15 08 	lsl	r11,r9,0x8
80003810:	bf bb       	sbr	r11,0x1f
80003812:	b7 99       	lsr	r9,0x17
80003814:	1a dc       	st.w	--sp,r12
80003816:	c2 90       	breq	80003868 <__avr32_f32_sub_op2_subnormal>
80003818:	f4 09 01 0c 	sub	r12,r10,r9
8000381c:	c0 c0       	breq	80003834 <__avr32_f32_sub_shift_done>
8000381e:	f1 bc 04 a0 	satu	r12,0x5
80003822:	f8 09 11 20 	rsub	r9,r12,32
80003826:	f6 09 09 49 	lsl	r9,r11,r9
8000382a:	f7 b8 01 01 	subne	r8,1
8000382e:	5f 19       	srne	r9
80003830:	f6 0c 0a 4b 	lsr	r11,r11,r12

80003834 <__avr32_f32_sub_shift_done>:
80003834:	16 18       	sub	r8,r11
80003836:	1b 0c       	ld.w	r12,sp++
80003838:	f0 0b 12 00 	clz	r11,r8
8000383c:	5e 3d       	retlo	0
8000383e:	f0 0b 09 48 	lsl	r8,r8,r11
80003842:	16 1a       	sub	r10,r11
80003844:	e0 8a 00 26 	brle	80003890 <__avr32_f32_sub_subnormal_result>
80003848:	f3 e8 11 89 	or	r9,r9,r8<<0x18
8000384c:	f9 e8 12 8c 	or	r12,r12,r8>>0x8
80003850:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8

80003854 <__avr32_f32_sub_round>:
80003854:	fc 1a 80 00 	movh	r10,0x8000
80003858:	ed bc 00 00 	bld	r12,0x0
8000385c:	f7 ba 01 ff 	subne	r10,-1
80003860:	14 39       	cp.w	r9,r10
80003862:	f7 bc 02 ff 	subhs	r12,-1
80003866:	5e fc       	retal	r12

80003868 <__avr32_f32_sub_op2_subnormal>:
80003868:	bf db       	cbr	r11,0x1f
8000386a:	f9 b9 01 01 	movne	r9,1
8000386e:	58 0a       	cp.w	r10,0
80003870:	cd 41       	brne	80003818 <__avr32_f32_sub+0x3c>
80003872:	bf d8       	cbr	r8,0x1f
80003874:	f9 ba 01 01 	movne	r10,1
80003878:	cd 0b       	rjmp	80003818 <__avr32_f32_sub+0x3c>

8000387a <__avr32_f32_sub_op1_nan_or_inf>:
8000387a:	f0 0b 15 01 	lsl	r11,r8,0x1
8000387e:	5e 1e       	retne	-1
80003880:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80003884:	f2 0b 16 17 	lsr	r11,r9,0x17
80003888:	e0 4b 00 ff 	cp.w	r11,255
8000388c:	5e 1c       	retne	r12
8000388e:	5e fe       	retal	-1

80003890 <__avr32_f32_sub_subnormal_result>:
80003890:	f4 0a 11 09 	rsub	r10,r10,9
80003894:	f4 0b 11 20 	rsub	r11,r10,32
80003898:	5e 3d       	retlo	0
8000389a:	f0 0a 0a 4a 	lsr	r10,r8,r10
8000389e:	14 4c       	or	r12,r10
800038a0:	f0 0b 09 48 	lsl	r8,r8,r11
800038a4:	10 49       	or	r9,r8
800038a6:	cd 7b       	rjmp	80003854 <__avr32_f32_sub_round>

800038a8 <__avr32_f32_add_from_sub>:
800038a8:	ee 1b 80 00 	eorh	r11,0x8000

800038ac <__avr32_f32_add>:
800038ac:	f7 ec 20 08 	eor	r8,r11,r12
800038b0:	c9 46       	brmi	800037d8 <__avr32_f32_sub_from_add>
800038b2:	18 98       	mov	r8,r12
800038b4:	e6 1c 80 00 	andh	r12,0x8000,COH
800038b8:	bf db       	cbr	r11,0x1f
800038ba:	bf d8       	cbr	r8,0x1f
800038bc:	f0 0b 0c 4a 	max	r10,r8,r11
800038c0:	f0 0b 0d 49 	min	r9,r8,r11
800038c4:	f4 08 15 08 	lsl	r8,r10,0x8
800038c8:	bf b8       	sbr	r8,0x1f
800038ca:	b7 9a       	lsr	r10,0x17
800038cc:	e0 4a 00 ff 	cp.w	r10,255
800038d0:	c2 d0       	breq	8000392a <__avr32_f32_add_op1_nan_or_inf>
800038d2:	f2 0b 15 08 	lsl	r11,r9,0x8
800038d6:	bf bb       	sbr	r11,0x1f
800038d8:	b7 99       	lsr	r9,0x17
800038da:	c1 e0       	breq	80003916 <__avr32_f32_add_op2_subnormal>
800038dc:	1a dc       	st.w	--sp,r12
800038de:	14 29       	rsub	r9,r10
800038e0:	f1 b9 04 a0 	satu	r9,0x5
800038e4:	f6 09 0a 4c 	lsr	r12,r11,r9
800038e8:	f2 09 11 18 	rsub	r9,r9,24
800038ec:	f6 09 09 4b 	lsl	r11,r11,r9
800038f0:	f7 dc d3 08 	bfins	r11,r12,0x18,0x8
800038f4:	18 08       	add	r8,r12
800038f6:	1b 0c       	ld.w	r12,sp++
800038f8:	c2 63       	brcs	80003944 <__avr32_f32_add_res_of>
800038fa:	f9 e8 12 8c 	or	r12,r12,r8>>0x8
800038fe:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80003902:	fc 1a 80 00 	movh	r10,0x8000
80003906:	ed bc 00 00 	bld	r12,0x0
8000390a:	f7 ba 01 ff 	subne	r10,-1
8000390e:	14 3b       	cp.w	r11,r10
80003910:	f7 bc 02 ff 	subhs	r12,-1
80003914:	5e fc       	retal	r12

80003916 <__avr32_f32_add_op2_subnormal>:
80003916:	bf db       	cbr	r11,0x1f
80003918:	f9 b9 01 01 	movne	r9,1
8000391c:	58 0a       	cp.w	r10,0
8000391e:	cd f1       	brne	800038dc <__avr32_f32_add+0x30>
80003920:	bf d8       	cbr	r8,0x1f
80003922:	10 0b       	add	r11,r8
80003924:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
80003928:	5e fc       	retal	r12

8000392a <__avr32_f32_add_op1_nan_or_inf>:
8000392a:	f0 0b 15 01 	lsl	r11,r8,0x1
8000392e:	5e 1e       	retne	-1
80003930:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80003934:	f2 0b 16 17 	lsr	r11,r9,0x17
80003938:	e0 4b 00 ff 	cp.w	r11,255
8000393c:	5e 1c       	retne	r12
8000393e:	a9 79       	lsl	r9,0x9
80003940:	5e 0c       	reteq	r12
80003942:	5e fe       	retal	-1

80003944 <__avr32_f32_add_res_of>:
80003944:	a1 98       	lsr	r8,0x1
80003946:	2f fa       	sub	r10,-1
80003948:	e0 4a 00 ff 	cp.w	r10,255
8000394c:	f9 b8 00 00 	moveq	r8,0
80003950:	f9 bb 00 00 	moveq	r11,0
80003954:	cd 3b       	rjmp	800038fa <__avr32_f32_add+0x4e>
80003956:	d7 03       	nop

80003958 <__avr32_f32_mul>:
80003958:	18 98       	mov	r8,r12
8000395a:	16 5c       	eor	r12,r11
8000395c:	e6 1c 80 00 	andh	r12,0x8000,COH
80003960:	bf d8       	cbr	r8,0x1f
80003962:	c6 60       	breq	80003a2e <__avr32_f32_mul_op1_zero>
80003964:	bf db       	cbr	r11,0x1f
80003966:	f0 0b 0c 4a 	max	r10,r8,r11
8000396a:	f0 0b 0d 49 	min	r9,r8,r11
8000396e:	f4 08 15 08 	lsl	r8,r10,0x8
80003972:	bf b8       	sbr	r8,0x1f
80003974:	b7 9a       	lsr	r10,0x17
80003976:	e0 4a 00 ff 	cp.w	r10,255
8000397a:	c3 d0       	breq	800039f4 <__avr32_f32_mul_op1_nan_or_inf>
8000397c:	f2 0b 15 08 	lsl	r11,r9,0x8
80003980:	bf bb       	sbr	r11,0x1f
80003982:	b7 99       	lsr	r9,0x17
80003984:	c2 40       	breq	800039cc <__avr32_f32_mul_op2_subnormal>
80003986:	14 09       	add	r9,r10
80003988:	f0 0b 06 4a 	mulu.d	r10,r8,r11
8000398c:	f6 08 15 01 	lsl	r8,r11,0x1
80003990:	f0 0b 17 20 	movhs	r11,r8
80003994:	f7 b9 02 01 	subhs	r9,1
80003998:	a9 8a       	lsr	r10,0x8
8000399a:	f5 db d3 08 	bfins	r10,r11,0x18,0x8
8000399e:	27 e9       	sub	r9,126
800039a0:	e0 8a 00 39 	brle	80003a12 <__avr32_f32_mul_res_subnormal>
800039a4:	e0 49 00 ff 	cp.w	r9,255
800039a8:	c0 f4       	brge	800039c6 <__avr32_f32_mul_round+0x14>
800039aa:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
800039ae:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8

800039b2 <__avr32_f32_mul_round>:
800039b2:	fc 18 80 00 	movh	r8,0x8000
800039b6:	ed bc 00 00 	bld	r12,0x0
800039ba:	f7 b8 01 ff 	subne	r8,-1
800039be:	10 3a       	cp.w	r10,r8
800039c0:	f7 bc 02 ff 	subhs	r12,-1
800039c4:	5e fc       	retal	r12
800039c6:	ea 1c 7f 80 	orh	r12,0x7f80
800039ca:	5e fc       	retal	r12

800039cc <__avr32_f32_mul_op2_subnormal>:
800039cc:	bf db       	cbr	r11,0x1f
800039ce:	f6 09 12 00 	clz	r9,r11
800039d2:	5e 3d       	retlo	0
800039d4:	20 89       	sub	r9,8
800039d6:	f6 09 09 4b 	lsl	r11,r11,r9
800039da:	f2 09 11 01 	rsub	r9,r9,1
800039de:	14 7a       	tst	r10,r10
800039e0:	cd 31       	brne	80003986 <__avr32_f32_mul+0x2e>
800039e2:	bf d8       	cbr	r8,0x1f
800039e4:	f6 0a 12 00 	clz	r10,r11
800039e8:	5e 3d       	retlo	0
800039ea:	f0 0a 09 48 	lsl	r8,r8,r10
800039ee:	f4 0a 11 01 	rsub	r10,r10,1
800039f2:	cc ab       	rjmp	80003986 <__avr32_f32_mul+0x2e>

800039f4 <__avr32_f32_mul_op1_nan_or_inf>:
800039f4:	f0 0b 15 01 	lsl	r11,r8,0x1
800039f8:	5e 1e       	retne	-1
800039fa:	12 79       	tst	r9,r9
800039fc:	5e 0e       	reteq	-1
800039fe:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80003a02:	f2 0b 16 17 	lsr	r11,r9,0x17
80003a06:	e0 4b 00 ff 	cp.w	r11,255
80003a0a:	5e 1c       	retne	r12
80003a0c:	a9 79       	lsl	r9,0x9
80003a0e:	5e 0c       	reteq	r12
80003a10:	5e fe       	retal	-1

80003a12 <__avr32_f32_mul_res_subnormal>:
80003a12:	f2 09 11 09 	rsub	r9,r9,9
80003a16:	f2 08 11 20 	rsub	r8,r9,32
80003a1a:	5e 3d       	retlo	0
80003a1c:	f6 09 0a 49 	lsr	r9,r11,r9
80003a20:	12 4c       	or	r12,r9
80003a22:	f6 08 09 4b 	lsl	r11,r11,r8
80003a26:	e4 1a 00 ff 	andh	r10,0xff
80003a2a:	16 4a       	or	r10,r11
80003a2c:	cc 3b       	rjmp	800039b2 <__avr32_f32_mul_round>

80003a2e <__avr32_f32_mul_op1_zero>:
80003a2e:	f5 db c2 e8 	bfextu	r10,r11,0x17,0x8
80003a32:	e0 4a 00 ff 	cp.w	r10,255
80003a36:	5e 1c       	retne	r12
80003a38:	5e 0e       	reteq	-1

80003a3a <__avr32_s32_to_f32>:
80003a3a:	58 0c       	cp.w	r12,0
80003a3c:	5e 0c       	reteq	r12
80003a3e:	18 9b       	mov	r11,r12
80003a40:	5c 4c       	abs	r12
80003a42:	e0 6a 00 9e 	mov	r10,158
80003a46:	f8 09 12 00 	clz	r9,r12
80003a4a:	12 1a       	sub	r10,r9
80003a4c:	f8 09 09 4c 	lsl	r12,r12,r9
80003a50:	58 0a       	cp.w	r10,0
80003a52:	e0 8a 00 15 	brle	80003a7c <__avr32_s32_to_f32_subnormal>
80003a56:	37 f9       	mov	r9,127
80003a58:	ed bc 00 08 	bld	r12,0x8
80003a5c:	f7 b9 00 ff 	subeq	r9,-1
80003a60:	12 0c       	add	r12,r9
80003a62:	f7 ba 03 fe 	sublo	r10,-2
80003a66:	ed bc 00 1f 	bld	r12,0x1f
80003a6a:	f7 ba 01 01 	subne	r10,1
80003a6e:	f8 0c 16 07 	lsr	r12,r12,0x7
80003a72:	f9 da d3 08 	bfins	r12,r10,0x18,0x8
80003a76:	a1 7b       	lsl	r11,0x1
80003a78:	5d 0c       	ror	r12
80003a7a:	5e fc       	retal	r12

80003a7c <__avr32_s32_to_f32_subnormal>:
80003a7c:	f4 0a 11 01 	rsub	r10,r10,1
80003a80:	59 9a       	cp.w	r10,25
80003a82:	f9 bc 02 00 	movhs	r12,0
80003a86:	c1 32       	brcc	80003aac <__avr32_s32_to_f32_subnormal+0x30>
80003a88:	f4 09 11 20 	rsub	r9,r10,32
80003a8c:	f8 09 09 49 	lsl	r9,r12,r9
80003a90:	5f 19       	srne	r9
80003a92:	f8 0a 0a 4c 	lsr	r12,r12,r10
80003a96:	12 4c       	or	r12,r9
80003a98:	37 f9       	mov	r9,127
80003a9a:	ed bc 00 08 	bld	r12,0x8
80003a9e:	f7 b9 00 ff 	subeq	r9,-1
80003aa2:	12 0c       	add	r12,r9
80003aa4:	f8 0c 16 07 	lsr	r12,r12,0x7
80003aa8:	a1 7b       	lsl	r11,0x1
80003aaa:	5d 0c       	ror	r12
80003aac:	5e fc       	retal	r12

80003aae <__avr32_f32_to_s32>:
80003aae:	f7 dc c2 e8 	bfextu	r11,r12,0x17,0x8
80003ab2:	27 fb       	sub	r11,127
80003ab4:	5e 3d       	retlo	0
80003ab6:	f6 0b 11 1f 	rsub	r11,r11,31
80003aba:	f8 0a 15 08 	lsl	r10,r12,0x8
80003abe:	bf ba       	sbr	r10,0x1f
80003ac0:	f4 0b 0a 4a 	lsr	r10,r10,r11
80003ac4:	a1 7c       	lsl	r12,0x1
80003ac6:	5e 2a       	reths	r10
80003ac8:	5c 3a       	neg	r10
80003aca:	5e fa       	retal	r10

80003acc <atexit>:
80003acc:	d4 01       	pushm	lr
80003ace:	30 09       	mov	r9,0
80003ad0:	18 9b       	mov	r11,r12
80003ad2:	12 9a       	mov	r10,r9
80003ad4:	12 9c       	mov	r12,r9
80003ad6:	e0 a0 03 2f 	rcall	80004134 <__register_exitproc>
80003ada:	d8 02       	popm	pc

80003adc <exit>:
80003adc:	d4 21       	pushm	r4-r7,lr
80003ade:	30 0b       	mov	r11,0
80003ae0:	18 97       	mov	r7,r12
80003ae2:	e0 a0 03 7b 	rcall	800041d8 <__call_exitprocs>
80003ae6:	fe c8 f1 e2 	sub	r8,pc,-3614
80003aea:	70 0c       	ld.w	r12,r8[0x0]
80003aec:	78 a8       	ld.w	r8,r12[0x28]
80003aee:	58 08       	cp.w	r8,0
80003af0:	c0 20       	breq	80003af4 <exit+0x18>
80003af2:	5d 18       	icall	r8
80003af4:	0e 9c       	mov	r12,r7
80003af6:	e0 a0 02 fe 	rcall	800040f2 <_exit>
80003afa:	d7 03       	nop

80003afc <free>:
80003afc:	d4 01       	pushm	lr
80003afe:	e0 68 01 2c 	mov	r8,300
80003b02:	18 9b       	mov	r11,r12
80003b04:	70 0c       	ld.w	r12,r8[0x0]
80003b06:	e0 a0 04 1d 	rcall	80004340 <_free_r>
80003b0a:	d8 02       	popm	pc

80003b0c <malloc>:
80003b0c:	d4 01       	pushm	lr
80003b0e:	e0 68 01 2c 	mov	r8,300
80003b12:	18 9b       	mov	r11,r12
80003b14:	70 0c       	ld.w	r12,r8[0x0]
80003b16:	c0 3c       	rcall	80003b1c <_malloc_r>
80003b18:	d8 02       	popm	pc
80003b1a:	d7 03       	nop

80003b1c <_malloc_r>:
80003b1c:	d4 31       	pushm	r0-r7,lr
80003b1e:	f6 c8 ff f5 	sub	r8,r11,-11
80003b22:	18 95       	mov	r5,r12
80003b24:	10 97       	mov	r7,r8
80003b26:	e0 17 ff f8 	andl	r7,0xfff8
80003b2a:	59 68       	cp.w	r8,22
80003b2c:	f9 b7 08 10 	movls	r7,16
80003b30:	16 37       	cp.w	r7,r11
80003b32:	5f 38       	srlo	r8
80003b34:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80003b38:	c0 50       	breq	80003b42 <_malloc_r+0x26>
80003b3a:	30 c8       	mov	r8,12
80003b3c:	99 38       	st.w	r12[0xc],r8
80003b3e:	e0 8f 01 f8 	bral	80003f2e <_malloc_r+0x412>
80003b42:	fe b0 f7 c7 	rcall	80002ad0 <__malloc_lock>
80003b46:	e0 47 01 f7 	cp.w	r7,503
80003b4a:	e0 8b 00 1d 	brhi	80003b84 <_malloc_r+0x68>
80003b4e:	ee 03 16 03 	lsr	r3,r7,0x3
80003b52:	e0 68 01 30 	mov	r8,304
80003b56:	f0 03 00 38 	add	r8,r8,r3<<0x3
80003b5a:	70 36       	ld.w	r6,r8[0xc]
80003b5c:	10 36       	cp.w	r6,r8
80003b5e:	c0 61       	brne	80003b6a <_malloc_r+0x4e>
80003b60:	ec c8 ff f8 	sub	r8,r6,-8
80003b64:	70 36       	ld.w	r6,r8[0xc]
80003b66:	10 36       	cp.w	r6,r8
80003b68:	c0 c0       	breq	80003b80 <_malloc_r+0x64>
80003b6a:	6c 18       	ld.w	r8,r6[0x4]
80003b6c:	e0 18 ff fc 	andl	r8,0xfffc
80003b70:	6c 3a       	ld.w	r10,r6[0xc]
80003b72:	ec 08 00 09 	add	r9,r6,r8
80003b76:	0a 9c       	mov	r12,r5
80003b78:	6c 28       	ld.w	r8,r6[0x8]
80003b7a:	95 28       	st.w	r10[0x8],r8
80003b7c:	91 3a       	st.w	r8[0xc],r10
80003b7e:	c4 78       	rjmp	80003c0c <_malloc_r+0xf0>
80003b80:	2f e3       	sub	r3,-2
80003b82:	c4 d8       	rjmp	80003c1c <_malloc_r+0x100>
80003b84:	ee 03 16 09 	lsr	r3,r7,0x9
80003b88:	c0 41       	brne	80003b90 <_malloc_r+0x74>
80003b8a:	ee 03 16 03 	lsr	r3,r7,0x3
80003b8e:	c2 68       	rjmp	80003bda <_malloc_r+0xbe>
80003b90:	58 43       	cp.w	r3,4
80003b92:	e0 8b 00 06 	brhi	80003b9e <_malloc_r+0x82>
80003b96:	ee 03 16 06 	lsr	r3,r7,0x6
80003b9a:	2c 83       	sub	r3,-56
80003b9c:	c1 f8       	rjmp	80003bda <_malloc_r+0xbe>
80003b9e:	59 43       	cp.w	r3,20
80003ba0:	e0 8b 00 04 	brhi	80003ba8 <_malloc_r+0x8c>
80003ba4:	2a 53       	sub	r3,-91
80003ba6:	c1 a8       	rjmp	80003bda <_malloc_r+0xbe>
80003ba8:	e0 43 00 54 	cp.w	r3,84
80003bac:	e0 8b 00 06 	brhi	80003bb8 <_malloc_r+0x9c>
80003bb0:	ee 03 16 0c 	lsr	r3,r7,0xc
80003bb4:	29 23       	sub	r3,-110
80003bb6:	c1 28       	rjmp	80003bda <_malloc_r+0xbe>
80003bb8:	e0 43 01 54 	cp.w	r3,340
80003bbc:	e0 8b 00 06 	brhi	80003bc8 <_malloc_r+0xac>
80003bc0:	ee 03 16 0f 	lsr	r3,r7,0xf
80003bc4:	28 93       	sub	r3,-119
80003bc6:	c0 a8       	rjmp	80003bda <_malloc_r+0xbe>
80003bc8:	e0 43 05 54 	cp.w	r3,1364
80003bcc:	e0 88 00 04 	brls	80003bd4 <_malloc_r+0xb8>
80003bd0:	37 e3       	mov	r3,126
80003bd2:	c0 48       	rjmp	80003bda <_malloc_r+0xbe>
80003bd4:	ee 03 16 12 	lsr	r3,r7,0x12
80003bd8:	28 43       	sub	r3,-124
80003bda:	e0 6a 01 30 	mov	r10,304
80003bde:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80003be2:	74 36       	ld.w	r6,r10[0xc]
80003be4:	c1 98       	rjmp	80003c16 <_malloc_r+0xfa>
80003be6:	6c 19       	ld.w	r9,r6[0x4]
80003be8:	e0 19 ff fc 	andl	r9,0xfffc
80003bec:	f2 07 01 0b 	sub	r11,r9,r7
80003bf0:	58 fb       	cp.w	r11,15
80003bf2:	e0 8a 00 04 	brle	80003bfa <_malloc_r+0xde>
80003bf6:	20 13       	sub	r3,1
80003bf8:	c1 18       	rjmp	80003c1a <_malloc_r+0xfe>
80003bfa:	6c 38       	ld.w	r8,r6[0xc]
80003bfc:	58 0b       	cp.w	r11,0
80003bfe:	c0 b5       	brlt	80003c14 <_malloc_r+0xf8>
80003c00:	6c 2a       	ld.w	r10,r6[0x8]
80003c02:	ec 09 00 09 	add	r9,r6,r9
80003c06:	0a 9c       	mov	r12,r5
80003c08:	91 2a       	st.w	r8[0x8],r10
80003c0a:	95 38       	st.w	r10[0xc],r8
80003c0c:	72 18       	ld.w	r8,r9[0x4]
80003c0e:	a1 a8       	sbr	r8,0x0
80003c10:	93 18       	st.w	r9[0x4],r8
80003c12:	cb c8       	rjmp	80003d8a <_malloc_r+0x26e>
80003c14:	10 96       	mov	r6,r8
80003c16:	14 36       	cp.w	r6,r10
80003c18:	ce 71       	brne	80003be6 <_malloc_r+0xca>
80003c1a:	2f f3       	sub	r3,-1
80003c1c:	e0 6a 01 30 	mov	r10,304
80003c20:	f4 cc ff f8 	sub	r12,r10,-8
80003c24:	78 26       	ld.w	r6,r12[0x8]
80003c26:	18 36       	cp.w	r6,r12
80003c28:	c6 c0       	breq	80003d00 <_malloc_r+0x1e4>
80003c2a:	6c 19       	ld.w	r9,r6[0x4]
80003c2c:	e0 19 ff fc 	andl	r9,0xfffc
80003c30:	f2 07 01 08 	sub	r8,r9,r7
80003c34:	58 f8       	cp.w	r8,15
80003c36:	e0 89 00 8f 	brgt	80003d54 <_malloc_r+0x238>
80003c3a:	99 3c       	st.w	r12[0xc],r12
80003c3c:	99 2c       	st.w	r12[0x8],r12
80003c3e:	58 08       	cp.w	r8,0
80003c40:	c0 55       	brlt	80003c4a <_malloc_r+0x12e>
80003c42:	ec 09 00 09 	add	r9,r6,r9
80003c46:	0a 9c       	mov	r12,r5
80003c48:	ce 2b       	rjmp	80003c0c <_malloc_r+0xf0>
80003c4a:	e0 49 01 ff 	cp.w	r9,511
80003c4e:	e0 8b 00 13 	brhi	80003c74 <_malloc_r+0x158>
80003c52:	a3 99       	lsr	r9,0x3
80003c54:	f4 09 00 38 	add	r8,r10,r9<<0x3
80003c58:	70 2b       	ld.w	r11,r8[0x8]
80003c5a:	8d 38       	st.w	r6[0xc],r8
80003c5c:	8d 2b       	st.w	r6[0x8],r11
80003c5e:	97 36       	st.w	r11[0xc],r6
80003c60:	91 26       	st.w	r8[0x8],r6
80003c62:	a3 49       	asr	r9,0x2
80003c64:	74 18       	ld.w	r8,r10[0x4]
80003c66:	30 1b       	mov	r11,1
80003c68:	f6 09 09 49 	lsl	r9,r11,r9
80003c6c:	f1 e9 10 09 	or	r9,r8,r9
80003c70:	95 19       	st.w	r10[0x4],r9
80003c72:	c4 78       	rjmp	80003d00 <_malloc_r+0x1e4>
80003c74:	f2 0a 16 09 	lsr	r10,r9,0x9
80003c78:	58 4a       	cp.w	r10,4
80003c7a:	e0 8b 00 07 	brhi	80003c88 <_malloc_r+0x16c>
80003c7e:	f2 0a 16 06 	lsr	r10,r9,0x6
80003c82:	2c 8a       	sub	r10,-56
80003c84:	c2 08       	rjmp	80003cc4 <_malloc_r+0x1a8>
80003c86:	d7 03       	nop
80003c88:	59 4a       	cp.w	r10,20
80003c8a:	e0 8b 00 04 	brhi	80003c92 <_malloc_r+0x176>
80003c8e:	2a 5a       	sub	r10,-91
80003c90:	c1 a8       	rjmp	80003cc4 <_malloc_r+0x1a8>
80003c92:	e0 4a 00 54 	cp.w	r10,84
80003c96:	e0 8b 00 06 	brhi	80003ca2 <_malloc_r+0x186>
80003c9a:	f2 0a 16 0c 	lsr	r10,r9,0xc
80003c9e:	29 2a       	sub	r10,-110
80003ca0:	c1 28       	rjmp	80003cc4 <_malloc_r+0x1a8>
80003ca2:	e0 4a 01 54 	cp.w	r10,340
80003ca6:	e0 8b 00 06 	brhi	80003cb2 <_malloc_r+0x196>
80003caa:	f2 0a 16 0f 	lsr	r10,r9,0xf
80003cae:	28 9a       	sub	r10,-119
80003cb0:	c0 a8       	rjmp	80003cc4 <_malloc_r+0x1a8>
80003cb2:	e0 4a 05 54 	cp.w	r10,1364
80003cb6:	e0 88 00 04 	brls	80003cbe <_malloc_r+0x1a2>
80003cba:	37 ea       	mov	r10,126
80003cbc:	c0 48       	rjmp	80003cc4 <_malloc_r+0x1a8>
80003cbe:	f2 0a 16 12 	lsr	r10,r9,0x12
80003cc2:	28 4a       	sub	r10,-124
80003cc4:	e0 6b 01 30 	mov	r11,304
80003cc8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80003ccc:	68 28       	ld.w	r8,r4[0x8]
80003cce:	08 38       	cp.w	r8,r4
80003cd0:	c0 e1       	brne	80003cec <_malloc_r+0x1d0>
80003cd2:	76 19       	ld.w	r9,r11[0x4]
80003cd4:	a3 4a       	asr	r10,0x2
80003cd6:	30 1e       	mov	lr,1
80003cd8:	fc 0a 09 4a 	lsl	r10,lr,r10
80003cdc:	f3 ea 10 0a 	or	r10,r9,r10
80003ce0:	10 99       	mov	r9,r8
80003ce2:	97 1a       	st.w	r11[0x4],r10
80003ce4:	c0 a8       	rjmp	80003cf8 <_malloc_r+0x1dc>
80003ce6:	70 28       	ld.w	r8,r8[0x8]
80003ce8:	08 38       	cp.w	r8,r4
80003cea:	c0 60       	breq	80003cf6 <_malloc_r+0x1da>
80003cec:	70 1a       	ld.w	r10,r8[0x4]
80003cee:	e0 1a ff fc 	andl	r10,0xfffc
80003cf2:	14 39       	cp.w	r9,r10
80003cf4:	cf 93       	brcs	80003ce6 <_malloc_r+0x1ca>
80003cf6:	70 39       	ld.w	r9,r8[0xc]
80003cf8:	8d 39       	st.w	r6[0xc],r9
80003cfa:	8d 28       	st.w	r6[0x8],r8
80003cfc:	91 36       	st.w	r8[0xc],r6
80003cfe:	93 26       	st.w	r9[0x8],r6
80003d00:	e6 08 14 02 	asr	r8,r3,0x2
80003d04:	30 1b       	mov	r11,1
80003d06:	e0 64 01 30 	mov	r4,304
80003d0a:	f6 08 09 4b 	lsl	r11,r11,r8
80003d0e:	68 18       	ld.w	r8,r4[0x4]
80003d10:	10 3b       	cp.w	r11,r8
80003d12:	e0 8b 00 6b 	brhi	80003de8 <_malloc_r+0x2cc>
80003d16:	f7 e8 00 09 	and	r9,r11,r8
80003d1a:	c0 b1       	brne	80003d30 <_malloc_r+0x214>
80003d1c:	e0 13 ff fc 	andl	r3,0xfffc
80003d20:	a1 7b       	lsl	r11,0x1
80003d22:	2f c3       	sub	r3,-4
80003d24:	c0 38       	rjmp	80003d2a <_malloc_r+0x20e>
80003d26:	2f c3       	sub	r3,-4
80003d28:	a1 7b       	lsl	r11,0x1
80003d2a:	f7 e8 00 09 	and	r9,r11,r8
80003d2e:	cf c0       	breq	80003d26 <_malloc_r+0x20a>
80003d30:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80003d34:	06 92       	mov	r2,r3
80003d36:	1c 91       	mov	r1,lr
80003d38:	62 36       	ld.w	r6,r1[0xc]
80003d3a:	c2 e8       	rjmp	80003d96 <_malloc_r+0x27a>
80003d3c:	6c 1a       	ld.w	r10,r6[0x4]
80003d3e:	e0 1a ff fc 	andl	r10,0xfffc
80003d42:	f4 07 01 08 	sub	r8,r10,r7
80003d46:	58 f8       	cp.w	r8,15
80003d48:	e0 8a 00 15 	brle	80003d72 <_malloc_r+0x256>
80003d4c:	6c 3a       	ld.w	r10,r6[0xc]
80003d4e:	6c 29       	ld.w	r9,r6[0x8]
80003d50:	95 29       	st.w	r10[0x8],r9
80003d52:	93 3a       	st.w	r9[0xc],r10
80003d54:	0e 99       	mov	r9,r7
80003d56:	ec 07 00 07 	add	r7,r6,r7
80003d5a:	a1 a9       	sbr	r9,0x0
80003d5c:	99 37       	st.w	r12[0xc],r7
80003d5e:	99 27       	st.w	r12[0x8],r7
80003d60:	8d 19       	st.w	r6[0x4],r9
80003d62:	ee 08 09 08 	st.w	r7[r8],r8
80003d66:	8f 2c       	st.w	r7[0x8],r12
80003d68:	8f 3c       	st.w	r7[0xc],r12
80003d6a:	a1 a8       	sbr	r8,0x0
80003d6c:	0a 9c       	mov	r12,r5
80003d6e:	8f 18       	st.w	r7[0x4],r8
80003d70:	c0 d8       	rjmp	80003d8a <_malloc_r+0x26e>
80003d72:	6c 39       	ld.w	r9,r6[0xc]
80003d74:	58 08       	cp.w	r8,0
80003d76:	c0 f5       	brlt	80003d94 <_malloc_r+0x278>
80003d78:	ec 0a 00 0a 	add	r10,r6,r10
80003d7c:	74 18       	ld.w	r8,r10[0x4]
80003d7e:	a1 a8       	sbr	r8,0x0
80003d80:	0a 9c       	mov	r12,r5
80003d82:	95 18       	st.w	r10[0x4],r8
80003d84:	6c 28       	ld.w	r8,r6[0x8]
80003d86:	93 28       	st.w	r9[0x8],r8
80003d88:	91 39       	st.w	r8[0xc],r9
80003d8a:	fe b0 f6 a9 	rcall	80002adc <__malloc_unlock>
80003d8e:	ec cc ff f8 	sub	r12,r6,-8
80003d92:	d8 32       	popm	r0-r7,pc
80003d94:	12 96       	mov	r6,r9
80003d96:	02 36       	cp.w	r6,r1
80003d98:	cd 21       	brne	80003d3c <_malloc_r+0x220>
80003d9a:	2f f2       	sub	r2,-1
80003d9c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80003da0:	c0 30       	breq	80003da6 <_malloc_r+0x28a>
80003da2:	2f 81       	sub	r1,-8
80003da4:	cc ab       	rjmp	80003d38 <_malloc_r+0x21c>
80003da6:	1c 98       	mov	r8,lr
80003da8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80003dac:	c0 81       	brne	80003dbc <_malloc_r+0x2a0>
80003dae:	68 19       	ld.w	r9,r4[0x4]
80003db0:	f6 08 11 ff 	rsub	r8,r11,-1
80003db4:	f3 e8 00 08 	and	r8,r9,r8
80003db8:	89 18       	st.w	r4[0x4],r8
80003dba:	c0 78       	rjmp	80003dc8 <_malloc_r+0x2ac>
80003dbc:	f0 c9 00 08 	sub	r9,r8,8
80003dc0:	20 13       	sub	r3,1
80003dc2:	70 08       	ld.w	r8,r8[0x0]
80003dc4:	12 38       	cp.w	r8,r9
80003dc6:	cf 10       	breq	80003da8 <_malloc_r+0x28c>
80003dc8:	a1 7b       	lsl	r11,0x1
80003dca:	68 18       	ld.w	r8,r4[0x4]
80003dcc:	10 3b       	cp.w	r11,r8
80003dce:	e0 8b 00 0d 	brhi	80003de8 <_malloc_r+0x2cc>
80003dd2:	58 0b       	cp.w	r11,0
80003dd4:	c0 a0       	breq	80003de8 <_malloc_r+0x2cc>
80003dd6:	04 93       	mov	r3,r2
80003dd8:	c0 38       	rjmp	80003dde <_malloc_r+0x2c2>
80003dda:	2f c3       	sub	r3,-4
80003ddc:	a1 7b       	lsl	r11,0x1
80003dde:	f7 e8 00 09 	and	r9,r11,r8
80003de2:	ca 71       	brne	80003d30 <_malloc_r+0x214>
80003de4:	cf bb       	rjmp	80003dda <_malloc_r+0x2be>
80003de6:	d7 03       	nop
80003de8:	68 23       	ld.w	r3,r4[0x8]
80003dea:	66 12       	ld.w	r2,r3[0x4]
80003dec:	e0 12 ff fc 	andl	r2,0xfffc
80003df0:	0e 32       	cp.w	r2,r7
80003df2:	5f 39       	srlo	r9
80003df4:	e4 07 01 08 	sub	r8,r2,r7
80003df8:	58 f8       	cp.w	r8,15
80003dfa:	5f aa       	srle	r10
80003dfc:	f5 e9 10 09 	or	r9,r10,r9
80003e00:	e0 80 00 98 	breq	80003f30 <_malloc_r+0x414>
80003e04:	e0 68 07 90 	mov	r8,1936
80003e08:	70 01       	ld.w	r1,r8[0x0]
80003e0a:	e0 68 05 3c 	mov	r8,1340
80003e0e:	2f 01       	sub	r1,-16
80003e10:	70 08       	ld.w	r8,r8[0x0]
80003e12:	0e 01       	add	r1,r7
80003e14:	5b f8       	cp.w	r8,-1
80003e16:	c0 40       	breq	80003e1e <_malloc_r+0x302>
80003e18:	28 11       	sub	r1,-127
80003e1a:	e0 11 ff 80 	andl	r1,0xff80
80003e1e:	02 9b       	mov	r11,r1
80003e20:	0a 9c       	mov	r12,r5
80003e22:	c4 3d       	rcall	800040a8 <_sbrk_r>
80003e24:	18 96       	mov	r6,r12
80003e26:	5b fc       	cp.w	r12,-1
80003e28:	c7 40       	breq	80003f10 <_malloc_r+0x3f4>
80003e2a:	e6 02 00 08 	add	r8,r3,r2
80003e2e:	10 3c       	cp.w	r12,r8
80003e30:	c0 32       	brcc	80003e36 <_malloc_r+0x31a>
80003e32:	08 33       	cp.w	r3,r4
80003e34:	c6 e1       	brne	80003f10 <_malloc_r+0x3f4>
80003e36:	e0 6a 07 94 	mov	r10,1940
80003e3a:	74 09       	ld.w	r9,r10[0x0]
80003e3c:	e2 09 00 09 	add	r9,r1,r9
80003e40:	95 09       	st.w	r10[0x0],r9
80003e42:	10 36       	cp.w	r6,r8
80003e44:	c0 a1       	brne	80003e58 <_malloc_r+0x33c>
80003e46:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80003e4a:	c0 71       	brne	80003e58 <_malloc_r+0x33c>
80003e4c:	e2 02 00 02 	add	r2,r1,r2
80003e50:	68 28       	ld.w	r8,r4[0x8]
80003e52:	a1 a2       	sbr	r2,0x0
80003e54:	91 12       	st.w	r8[0x4],r2
80003e56:	c4 e8       	rjmp	80003ef2 <_malloc_r+0x3d6>
80003e58:	e0 6a 05 3c 	mov	r10,1340
80003e5c:	74 0b       	ld.w	r11,r10[0x0]
80003e5e:	5b fb       	cp.w	r11,-1
80003e60:	c0 31       	brne	80003e66 <_malloc_r+0x34a>
80003e62:	95 06       	st.w	r10[0x0],r6
80003e64:	c0 78       	rjmp	80003e72 <_malloc_r+0x356>
80003e66:	ec 09 00 09 	add	r9,r6,r9
80003e6a:	e0 6a 07 94 	mov	r10,1940
80003e6e:	10 19       	sub	r9,r8
80003e70:	95 09       	st.w	r10[0x0],r9
80003e72:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80003e76:	f0 09 11 08 	rsub	r9,r8,8
80003e7a:	58 08       	cp.w	r8,0
80003e7c:	f2 08 17 10 	movne	r8,r9
80003e80:	ed d8 e1 06 	addne	r6,r6,r8
80003e84:	28 08       	sub	r8,-128
80003e86:	ec 01 00 01 	add	r1,r6,r1
80003e8a:	0a 9c       	mov	r12,r5
80003e8c:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80003e90:	f0 01 01 01 	sub	r1,r8,r1
80003e94:	02 9b       	mov	r11,r1
80003e96:	c0 9d       	rcall	800040a8 <_sbrk_r>
80003e98:	e0 68 07 94 	mov	r8,1940
80003e9c:	5b fc       	cp.w	r12,-1
80003e9e:	ec 0c 17 00 	moveq	r12,r6
80003ea2:	f9 b1 00 00 	moveq	r1,0
80003ea6:	70 09       	ld.w	r9,r8[0x0]
80003ea8:	0c 1c       	sub	r12,r6
80003eaa:	89 26       	st.w	r4[0x8],r6
80003eac:	02 0c       	add	r12,r1
80003eae:	12 01       	add	r1,r9
80003eb0:	a1 ac       	sbr	r12,0x0
80003eb2:	91 01       	st.w	r8[0x0],r1
80003eb4:	8d 1c       	st.w	r6[0x4],r12
80003eb6:	08 33       	cp.w	r3,r4
80003eb8:	c1 d0       	breq	80003ef2 <_malloc_r+0x3d6>
80003eba:	58 f2       	cp.w	r2,15
80003ebc:	e0 8b 00 05 	brhi	80003ec6 <_malloc_r+0x3aa>
80003ec0:	30 18       	mov	r8,1
80003ec2:	8d 18       	st.w	r6[0x4],r8
80003ec4:	c2 68       	rjmp	80003f10 <_malloc_r+0x3f4>
80003ec6:	30 59       	mov	r9,5
80003ec8:	20 c2       	sub	r2,12
80003eca:	e0 12 ff f8 	andl	r2,0xfff8
80003ece:	e6 02 00 08 	add	r8,r3,r2
80003ed2:	91 29       	st.w	r8[0x8],r9
80003ed4:	91 19       	st.w	r8[0x4],r9
80003ed6:	66 18       	ld.w	r8,r3[0x4]
80003ed8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003edc:	e5 e8 10 08 	or	r8,r2,r8
80003ee0:	87 18       	st.w	r3[0x4],r8
80003ee2:	58 f2       	cp.w	r2,15
80003ee4:	e0 88 00 07 	brls	80003ef2 <_malloc_r+0x3d6>
80003ee8:	e6 cb ff f8 	sub	r11,r3,-8
80003eec:	0a 9c       	mov	r12,r5
80003eee:	e0 a0 02 29 	rcall	80004340 <_free_r>
80003ef2:	e0 69 07 8c 	mov	r9,1932
80003ef6:	72 0a       	ld.w	r10,r9[0x0]
80003ef8:	e0 68 07 94 	mov	r8,1940
80003efc:	70 08       	ld.w	r8,r8[0x0]
80003efe:	14 38       	cp.w	r8,r10
80003f00:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80003f04:	e0 69 07 88 	mov	r9,1928
80003f08:	72 0a       	ld.w	r10,r9[0x0]
80003f0a:	14 38       	cp.w	r8,r10
80003f0c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80003f10:	68 28       	ld.w	r8,r4[0x8]
80003f12:	70 18       	ld.w	r8,r8[0x4]
80003f14:	e0 18 ff fc 	andl	r8,0xfffc
80003f18:	0e 38       	cp.w	r8,r7
80003f1a:	5f 39       	srlo	r9
80003f1c:	0e 18       	sub	r8,r7
80003f1e:	58 f8       	cp.w	r8,15
80003f20:	5f aa       	srle	r10
80003f22:	f5 e9 10 09 	or	r9,r10,r9
80003f26:	c0 50       	breq	80003f30 <_malloc_r+0x414>
80003f28:	0a 9c       	mov	r12,r5
80003f2a:	fe b0 f5 d9 	rcall	80002adc <__malloc_unlock>
80003f2e:	d8 3a       	popm	r0-r7,pc,r12=0
80003f30:	68 26       	ld.w	r6,r4[0x8]
80003f32:	a1 a8       	sbr	r8,0x0
80003f34:	0e 99       	mov	r9,r7
80003f36:	a1 a9       	sbr	r9,0x0
80003f38:	8d 19       	st.w	r6[0x4],r9
80003f3a:	ec 07 00 07 	add	r7,r6,r7
80003f3e:	0a 9c       	mov	r12,r5
80003f40:	89 27       	st.w	r4[0x8],r7
80003f42:	8f 18       	st.w	r7[0x4],r8
80003f44:	fe b0 f5 cc 	rcall	80002adc <__malloc_unlock>
80003f48:	ec cc ff f8 	sub	r12,r6,-8
80003f4c:	d8 32       	popm	r0-r7,pc
80003f4e:	d7 03       	nop

80003f50 <memcpy>:
80003f50:	58 8a       	cp.w	r10,8
80003f52:	c2 f5       	brlt	80003fb0 <memcpy+0x60>
80003f54:	f9 eb 10 09 	or	r9,r12,r11
80003f58:	e2 19 00 03 	andl	r9,0x3,COH
80003f5c:	e0 81 00 97 	brne	8000408a <memcpy+0x13a>
80003f60:	e0 4a 00 20 	cp.w	r10,32
80003f64:	c3 b4       	brge	80003fda <memcpy+0x8a>
80003f66:	f4 08 14 02 	asr	r8,r10,0x2
80003f6a:	f0 09 11 08 	rsub	r9,r8,8
80003f6e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80003f72:	76 69       	ld.w	r9,r11[0x18]
80003f74:	99 69       	st.w	r12[0x18],r9
80003f76:	76 59       	ld.w	r9,r11[0x14]
80003f78:	99 59       	st.w	r12[0x14],r9
80003f7a:	76 49       	ld.w	r9,r11[0x10]
80003f7c:	99 49       	st.w	r12[0x10],r9
80003f7e:	76 39       	ld.w	r9,r11[0xc]
80003f80:	99 39       	st.w	r12[0xc],r9
80003f82:	76 29       	ld.w	r9,r11[0x8]
80003f84:	99 29       	st.w	r12[0x8],r9
80003f86:	76 19       	ld.w	r9,r11[0x4]
80003f88:	99 19       	st.w	r12[0x4],r9
80003f8a:	76 09       	ld.w	r9,r11[0x0]
80003f8c:	99 09       	st.w	r12[0x0],r9
80003f8e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80003f92:	f8 08 00 28 	add	r8,r12,r8<<0x2
80003f96:	e0 1a 00 03 	andl	r10,0x3
80003f9a:	f4 0a 11 04 	rsub	r10,r10,4
80003f9e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80003fa2:	17 a9       	ld.ub	r9,r11[0x2]
80003fa4:	b0 a9       	st.b	r8[0x2],r9
80003fa6:	17 99       	ld.ub	r9,r11[0x1]
80003fa8:	b0 99       	st.b	r8[0x1],r9
80003faa:	17 89       	ld.ub	r9,r11[0x0]
80003fac:	b0 89       	st.b	r8[0x0],r9
80003fae:	5e fc       	retal	r12
80003fb0:	f4 0a 11 09 	rsub	r10,r10,9
80003fb4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80003fb8:	17 f9       	ld.ub	r9,r11[0x7]
80003fba:	b8 f9       	st.b	r12[0x7],r9
80003fbc:	17 e9       	ld.ub	r9,r11[0x6]
80003fbe:	b8 e9       	st.b	r12[0x6],r9
80003fc0:	17 d9       	ld.ub	r9,r11[0x5]
80003fc2:	b8 d9       	st.b	r12[0x5],r9
80003fc4:	17 c9       	ld.ub	r9,r11[0x4]
80003fc6:	b8 c9       	st.b	r12[0x4],r9
80003fc8:	17 b9       	ld.ub	r9,r11[0x3]
80003fca:	b8 b9       	st.b	r12[0x3],r9
80003fcc:	17 a9       	ld.ub	r9,r11[0x2]
80003fce:	b8 a9       	st.b	r12[0x2],r9
80003fd0:	17 99       	ld.ub	r9,r11[0x1]
80003fd2:	b8 99       	st.b	r12[0x1],r9
80003fd4:	17 89       	ld.ub	r9,r11[0x0]
80003fd6:	b8 89       	st.b	r12[0x0],r9
80003fd8:	5e fc       	retal	r12
80003fda:	eb cd 40 c0 	pushm	r6-r7,lr
80003fde:	18 99       	mov	r9,r12
80003fe0:	22 0a       	sub	r10,32
80003fe2:	b7 07       	ld.d	r6,r11++
80003fe4:	b3 26       	st.d	r9++,r6
80003fe6:	b7 07       	ld.d	r6,r11++
80003fe8:	b3 26       	st.d	r9++,r6
80003fea:	b7 07       	ld.d	r6,r11++
80003fec:	b3 26       	st.d	r9++,r6
80003fee:	b7 07       	ld.d	r6,r11++
80003ff0:	b3 26       	st.d	r9++,r6
80003ff2:	22 0a       	sub	r10,32
80003ff4:	cf 74       	brge	80003fe2 <memcpy+0x92>
80003ff6:	2f 0a       	sub	r10,-16
80003ff8:	c0 65       	brlt	80004004 <memcpy+0xb4>
80003ffa:	b7 07       	ld.d	r6,r11++
80003ffc:	b3 26       	st.d	r9++,r6
80003ffe:	b7 07       	ld.d	r6,r11++
80004000:	b3 26       	st.d	r9++,r6
80004002:	21 0a       	sub	r10,16
80004004:	5c 3a       	neg	r10
80004006:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000400a:	d7 03       	nop
8000400c:	d7 03       	nop
8000400e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80004012:	f3 66 00 0e 	st.b	r9[14],r6
80004016:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000401a:	f3 66 00 0d 	st.b	r9[13],r6
8000401e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004022:	f3 66 00 0c 	st.b	r9[12],r6
80004026:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000402a:	f3 66 00 0b 	st.b	r9[11],r6
8000402e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80004032:	f3 66 00 0a 	st.b	r9[10],r6
80004036:	f7 36 00 09 	ld.ub	r6,r11[9]
8000403a:	f3 66 00 09 	st.b	r9[9],r6
8000403e:	f7 36 00 08 	ld.ub	r6,r11[8]
80004042:	f3 66 00 08 	st.b	r9[8],r6
80004046:	f7 36 00 07 	ld.ub	r6,r11[7]
8000404a:	f3 66 00 07 	st.b	r9[7],r6
8000404e:	f7 36 00 06 	ld.ub	r6,r11[6]
80004052:	f3 66 00 06 	st.b	r9[6],r6
80004056:	f7 36 00 05 	ld.ub	r6,r11[5]
8000405a:	f3 66 00 05 	st.b	r9[5],r6
8000405e:	f7 36 00 04 	ld.ub	r6,r11[4]
80004062:	f3 66 00 04 	st.b	r9[4],r6
80004066:	f7 36 00 03 	ld.ub	r6,r11[3]
8000406a:	f3 66 00 03 	st.b	r9[3],r6
8000406e:	f7 36 00 02 	ld.ub	r6,r11[2]
80004072:	f3 66 00 02 	st.b	r9[2],r6
80004076:	f7 36 00 01 	ld.ub	r6,r11[1]
8000407a:	f3 66 00 01 	st.b	r9[1],r6
8000407e:	f7 36 00 00 	ld.ub	r6,r11[0]
80004082:	f3 66 00 00 	st.b	r9[0],r6
80004086:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000408a:	20 1a       	sub	r10,1
8000408c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80004090:	f8 0a 0b 09 	st.b	r12[r10],r9
80004094:	cf b1       	brne	8000408a <memcpy+0x13a>
80004096:	5e fc       	retal	r12

80004098 <memset>:
80004098:	18 98       	mov	r8,r12
8000409a:	c0 38       	rjmp	800040a0 <memset+0x8>
8000409c:	10 cb       	st.b	r8++,r11
8000409e:	20 1a       	sub	r10,1
800040a0:	58 0a       	cp.w	r10,0
800040a2:	cf d1       	brne	8000409c <memset+0x4>
800040a4:	5e fc       	retal	r12
800040a6:	d7 03       	nop

800040a8 <_sbrk_r>:
800040a8:	d4 21       	pushm	r4-r7,lr
800040aa:	30 08       	mov	r8,0
800040ac:	18 97       	mov	r7,r12
800040ae:	e0 66 07 c0 	mov	r6,1984
800040b2:	16 9c       	mov	r12,r11
800040b4:	8d 08       	st.w	r6[0x0],r8
800040b6:	c2 3c       	rcall	800040fc <_sbrk>
800040b8:	5b fc       	cp.w	r12,-1
800040ba:	c0 51       	brne	800040c4 <_sbrk_r+0x1c>
800040bc:	6c 08       	ld.w	r8,r6[0x0]
800040be:	58 08       	cp.w	r8,0
800040c0:	ef f8 1a 03 	st.wne	r7[0xc],r8
800040c4:	d8 22       	popm	r4-r7,pc
800040c6:	d7 03       	nop

800040c8 <strncpy>:
800040c8:	30 08       	mov	r8,0
800040ca:	10 3a       	cp.w	r10,r8
800040cc:	5e 0c       	reteq	r12
800040ce:	f6 08 07 09 	ld.ub	r9,r11[r8]
800040d2:	f8 08 0b 09 	st.b	r12[r8],r9
800040d6:	2f f8       	sub	r8,-1
800040d8:	58 09       	cp.w	r9,0
800040da:	cf 81       	brne	800040ca <strncpy+0x2>
800040dc:	10 3a       	cp.w	r10,r8
800040de:	5e 0c       	reteq	r12
800040e0:	f8 08 0b 09 	st.b	r12[r8],r9
800040e4:	2f f8       	sub	r8,-1
800040e6:	cf bb       	rjmp	800040dc <strncpy+0x14>

800040e8 <_init_argv>:
800040e8:	30 e8       	mov	r8,14
800040ea:	d6 73       	breakpoint
800040ec:	3f fc       	mov	r12,-1
800040ee:	35 8b       	mov	r11,88
800040f0:	5e fc       	retal	r12

800040f2 <_exit>:
800040f2:	30 d8       	mov	r8,13
800040f4:	d6 73       	breakpoint
800040f6:	3f fc       	mov	r12,-1
800040f8:	35 8b       	mov	r11,88
800040fa:	c0 08       	rjmp	800040fa <_exit+0x8>

800040fc <_sbrk>:
800040fc:	d4 01       	pushm	lr
800040fe:	e0 68 07 bc 	mov	r8,1980
80004102:	70 09       	ld.w	r9,r8[0x0]
80004104:	58 09       	cp.w	r9,0
80004106:	c0 41       	brne	8000410e <_sbrk+0x12>
80004108:	e0 69 07 c8 	mov	r9,1992
8000410c:	91 09       	st.w	r8[0x0],r9
8000410e:	e0 69 07 bc 	mov	r9,1980
80004112:	e0 6a f0 00 	mov	r10,61440
80004116:	72 08       	ld.w	r8,r9[0x0]
80004118:	f0 0c 00 0c 	add	r12,r8,r12
8000411c:	14 3c       	cp.w	r12,r10
8000411e:	e0 8b 00 04 	brhi	80004126 <_sbrk+0x2a>
80004122:	93 0c       	st.w	r9[0x0],r12
80004124:	c0 58       	rjmp	8000412e <_sbrk+0x32>
80004126:	cb fc       	rcall	800042a4 <__errno>
80004128:	30 c8       	mov	r8,12
8000412a:	99 08       	st.w	r12[0x0],r8
8000412c:	3f f8       	mov	r8,-1
8000412e:	10 9c       	mov	r12,r8
80004130:	d8 02       	popm	pc
80004132:	d7 03       	nop

80004134 <__register_exitproc>:
80004134:	d4 31       	pushm	r0-r7,lr
80004136:	fe c8 f8 32 	sub	r8,pc,-1998
8000413a:	70 03       	ld.w	r3,r8[0x0]
8000413c:	67 24       	ld.w	r4,r3[0x48]
8000413e:	e6 c8 ff b4 	sub	r8,r3,-76
80004142:	58 04       	cp.w	r4,0
80004144:	f0 04 17 00 	moveq	r4,r8
80004148:	e7 f4 0a 12 	st.weq	r3[0x48],r4
8000414c:	18 97       	mov	r7,r12
8000414e:	16 96       	mov	r6,r11
80004150:	14 95       	mov	r5,r10
80004152:	12 92       	mov	r2,r9
80004154:	68 18       	ld.w	r8,r4[0x4]
80004156:	59 f8       	cp.w	r8,31
80004158:	e0 8a 00 0e 	brle	80004174 <__register_exitproc+0x40>
8000415c:	e0 6c 00 8c 	mov	r12,140
80004160:	fe b0 fc d6 	rcall	80003b0c <malloc>
80004164:	18 94       	mov	r4,r12
80004166:	c3 80       	breq	800041d6 <__register_exitproc+0xa2>
80004168:	67 28       	ld.w	r8,r3[0x48]
8000416a:	99 08       	st.w	r12[0x0],r8
8000416c:	e7 4c 00 48 	st.w	r3[72],r12
80004170:	30 08       	mov	r8,0
80004172:	99 18       	st.w	r12[0x4],r8
80004174:	58 07       	cp.w	r7,0
80004176:	c2 70       	breq	800041c4 <__register_exitproc+0x90>
80004178:	e8 fc 00 88 	ld.w	r12,r4[136]
8000417c:	58 0c       	cp.w	r12,0
8000417e:	c0 d1       	brne	80004198 <__register_exitproc+0x64>
80004180:	e0 6c 01 08 	mov	r12,264
80004184:	fe b0 fc c4 	rcall	80003b0c <malloc>
80004188:	c2 70       	breq	800041d6 <__register_exitproc+0xa2>
8000418a:	30 08       	mov	r8,0
8000418c:	e9 4c 00 88 	st.w	r4[136],r12
80004190:	f9 48 01 04 	st.w	r12[260],r8
80004194:	f9 48 01 00 	st.w	r12[256],r8
80004198:	68 18       	ld.w	r8,r4[0x4]
8000419a:	f0 c9 ff e0 	sub	r9,r8,-32
8000419e:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
800041a2:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
800041a6:	30 1a       	mov	r10,1
800041a8:	f8 f9 01 00 	ld.w	r9,r12[256]
800041ac:	f4 08 09 48 	lsl	r8,r10,r8
800041b0:	10 49       	or	r9,r8
800041b2:	f9 49 01 00 	st.w	r12[256],r9
800041b6:	58 27       	cp.w	r7,2
800041b8:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
800041bc:	f3 d8 e0 38 	oreq	r8,r9,r8
800041c0:	f9 f8 0a 41 	st.weq	r12[0x104],r8
800041c4:	68 18       	ld.w	r8,r4[0x4]
800041c6:	30 0c       	mov	r12,0
800041c8:	f0 c9 ff ff 	sub	r9,r8,-1
800041cc:	2f e8       	sub	r8,-2
800041ce:	89 19       	st.w	r4[0x4],r9
800041d0:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
800041d4:	d8 32       	popm	r0-r7,pc
800041d6:	dc 3a       	popm	r0-r7,pc,r12=-1

800041d8 <__call_exitprocs>:
800041d8:	d4 31       	pushm	r0-r7,lr
800041da:	20 3d       	sub	sp,12
800041dc:	fe c8 f8 d8 	sub	r8,pc,-1832
800041e0:	50 2c       	stdsp	sp[0x8],r12
800041e2:	70 08       	ld.w	r8,r8[0x0]
800041e4:	16 91       	mov	r1,r11
800041e6:	50 08       	stdsp	sp[0x0],r8
800041e8:	2b 88       	sub	r8,-72
800041ea:	50 18       	stdsp	sp[0x4],r8
800041ec:	40 0a       	lddsp	r10,sp[0x0]
800041ee:	40 14       	lddsp	r4,sp[0x4]
800041f0:	75 27       	ld.w	r7,r10[0x48]
800041f2:	c5 58       	rjmp	8000429c <__call_exitprocs+0xc4>
800041f4:	6e 15       	ld.w	r5,r7[0x4]
800041f6:	ee f6 00 88 	ld.w	r6,r7[136]
800041fa:	ea c2 ff ff 	sub	r2,r5,-1
800041fe:	20 15       	sub	r5,1
80004200:	ee 02 00 22 	add	r2,r7,r2<<0x2
80004204:	ec 05 00 23 	add	r3,r6,r5<<0x2
80004208:	c3 58       	rjmp	80004272 <__call_exitprocs+0x9a>
8000420a:	58 01       	cp.w	r1,0
8000420c:	c0 70       	breq	8000421a <__call_exitprocs+0x42>
8000420e:	58 06       	cp.w	r6,0
80004210:	c2 e0       	breq	8000426c <__call_exitprocs+0x94>
80004212:	e6 f8 00 80 	ld.w	r8,r3[128]
80004216:	02 38       	cp.w	r8,r1
80004218:	c2 a1       	brne	8000426c <__call_exitprocs+0x94>
8000421a:	6e 19       	ld.w	r9,r7[0x4]
8000421c:	64 08       	ld.w	r8,r2[0x0]
8000421e:	20 19       	sub	r9,1
80004220:	12 35       	cp.w	r5,r9
80004222:	ef f5 0a 01 	st.weq	r7[0x4],r5
80004226:	f9 b9 01 00 	movne	r9,0
8000422a:	e5 f9 1a 00 	st.wne	r2[0x0],r9
8000422e:	58 08       	cp.w	r8,0
80004230:	c1 e0       	breq	8000426c <__call_exitprocs+0x94>
80004232:	6e 10       	ld.w	r0,r7[0x4]
80004234:	58 06       	cp.w	r6,0
80004236:	c0 90       	breq	80004248 <__call_exitprocs+0x70>
80004238:	30 1a       	mov	r10,1
8000423a:	f4 05 09 49 	lsl	r9,r10,r5
8000423e:	ec fa 01 00 	ld.w	r10,r6[256]
80004242:	f3 ea 00 0a 	and	r10,r9,r10
80004246:	c0 31       	brne	8000424c <__call_exitprocs+0x74>
80004248:	5d 18       	icall	r8
8000424a:	c0 b8       	rjmp	80004260 <__call_exitprocs+0x88>
8000424c:	ec fa 01 04 	ld.w	r10,r6[260]
80004250:	66 0b       	ld.w	r11,r3[0x0]
80004252:	14 69       	and	r9,r10
80004254:	c0 41       	brne	8000425c <__call_exitprocs+0x84>
80004256:	40 2c       	lddsp	r12,sp[0x8]
80004258:	5d 18       	icall	r8
8000425a:	c0 38       	rjmp	80004260 <__call_exitprocs+0x88>
8000425c:	16 9c       	mov	r12,r11
8000425e:	5d 18       	icall	r8
80004260:	6e 18       	ld.w	r8,r7[0x4]
80004262:	10 30       	cp.w	r0,r8
80004264:	cc 41       	brne	800041ec <__call_exitprocs+0x14>
80004266:	68 08       	ld.w	r8,r4[0x0]
80004268:	0e 38       	cp.w	r8,r7
8000426a:	cc 11       	brne	800041ec <__call_exitprocs+0x14>
8000426c:	20 15       	sub	r5,1
8000426e:	20 43       	sub	r3,4
80004270:	20 42       	sub	r2,4
80004272:	58 05       	cp.w	r5,0
80004274:	cc b4       	brge	8000420a <__call_exitprocs+0x32>
80004276:	6e 18       	ld.w	r8,r7[0x4]
80004278:	58 08       	cp.w	r8,0
8000427a:	c0 f1       	brne	80004298 <__call_exitprocs+0xc0>
8000427c:	6e 08       	ld.w	r8,r7[0x0]
8000427e:	58 08       	cp.w	r8,0
80004280:	c0 c0       	breq	80004298 <__call_exitprocs+0xc0>
80004282:	89 08       	st.w	r4[0x0],r8
80004284:	58 06       	cp.w	r6,0
80004286:	c0 40       	breq	8000428e <__call_exitprocs+0xb6>
80004288:	0c 9c       	mov	r12,r6
8000428a:	fe b0 fc 39 	rcall	80003afc <free>
8000428e:	0e 9c       	mov	r12,r7
80004290:	fe b0 fc 36 	rcall	80003afc <free>
80004294:	68 07       	ld.w	r7,r4[0x0]
80004296:	c0 38       	rjmp	8000429c <__call_exitprocs+0xc4>
80004298:	0e 94       	mov	r4,r7
8000429a:	6e 07       	ld.w	r7,r7[0x0]
8000429c:	58 07       	cp.w	r7,0
8000429e:	ca b1       	brne	800041f4 <__call_exitprocs+0x1c>
800042a0:	2f dd       	sub	sp,-12
800042a2:	d8 32       	popm	r0-r7,pc

800042a4 <__errno>:
800042a4:	e0 68 01 2c 	mov	r8,300
800042a8:	70 0c       	ld.w	r12,r8[0x0]
800042aa:	2f 4c       	sub	r12,-12
800042ac:	5e fc       	retal	r12
800042ae:	d7 03       	nop

800042b0 <_malloc_trim_r>:
800042b0:	d4 21       	pushm	r4-r7,lr
800042b2:	16 95       	mov	r5,r11
800042b4:	18 97       	mov	r7,r12
800042b6:	fe b0 f4 0d 	rcall	80002ad0 <__malloc_lock>
800042ba:	e0 64 01 30 	mov	r4,304
800042be:	68 28       	ld.w	r8,r4[0x8]
800042c0:	70 16       	ld.w	r6,r8[0x4]
800042c2:	e0 16 ff fc 	andl	r6,0xfffc
800042c6:	ec c8 ff 91 	sub	r8,r6,-111
800042ca:	f0 05 01 05 	sub	r5,r8,r5
800042ce:	e0 15 ff 80 	andl	r5,0xff80
800042d2:	ea c5 00 80 	sub	r5,r5,128
800042d6:	e0 45 00 7f 	cp.w	r5,127
800042da:	e0 8a 00 22 	brle	8000431e <_malloc_trim_r+0x6e>
800042de:	30 0b       	mov	r11,0
800042e0:	0e 9c       	mov	r12,r7
800042e2:	ce 3e       	rcall	800040a8 <_sbrk_r>
800042e4:	68 28       	ld.w	r8,r4[0x8]
800042e6:	0c 08       	add	r8,r6
800042e8:	10 3c       	cp.w	r12,r8
800042ea:	c1 a1       	brne	8000431e <_malloc_trim_r+0x6e>
800042ec:	ea 0b 11 00 	rsub	r11,r5,0
800042f0:	0e 9c       	mov	r12,r7
800042f2:	cd be       	rcall	800040a8 <_sbrk_r>
800042f4:	5b fc       	cp.w	r12,-1
800042f6:	c1 81       	brne	80004326 <_malloc_trim_r+0x76>
800042f8:	30 0b       	mov	r11,0
800042fa:	0e 9c       	mov	r12,r7
800042fc:	cd 6e       	rcall	800040a8 <_sbrk_r>
800042fe:	68 28       	ld.w	r8,r4[0x8]
80004300:	f8 08 01 09 	sub	r9,r12,r8
80004304:	58 f9       	cp.w	r9,15
80004306:	e0 8a 00 0c 	brle	8000431e <_malloc_trim_r+0x6e>
8000430a:	a1 a9       	sbr	r9,0x0
8000430c:	91 19       	st.w	r8[0x4],r9
8000430e:	e0 68 05 3c 	mov	r8,1340
80004312:	70 09       	ld.w	r9,r8[0x0]
80004314:	e0 68 07 94 	mov	r8,1940
80004318:	f8 09 01 09 	sub	r9,r12,r9
8000431c:	91 09       	st.w	r8[0x0],r9
8000431e:	0e 9c       	mov	r12,r7
80004320:	fe b0 f3 de 	rcall	80002adc <__malloc_unlock>
80004324:	d8 2a       	popm	r4-r7,pc,r12=0
80004326:	68 28       	ld.w	r8,r4[0x8]
80004328:	0a 16       	sub	r6,r5
8000432a:	a1 a6       	sbr	r6,0x0
8000432c:	91 16       	st.w	r8[0x4],r6
8000432e:	e0 68 07 94 	mov	r8,1940
80004332:	70 09       	ld.w	r9,r8[0x0]
80004334:	0a 19       	sub	r9,r5
80004336:	0e 9c       	mov	r12,r7
80004338:	91 09       	st.w	r8[0x0],r9
8000433a:	fe b0 f3 d1 	rcall	80002adc <__malloc_unlock>
8000433e:	da 2a       	popm	r4-r7,pc,r12=1

80004340 <_free_r>:
80004340:	d4 21       	pushm	r4-r7,lr
80004342:	16 96       	mov	r6,r11
80004344:	18 97       	mov	r7,r12
80004346:	58 0b       	cp.w	r11,0
80004348:	e0 80 00 c0 	breq	800044c8 <_free_r+0x188>
8000434c:	fe b0 f3 c2 	rcall	80002ad0 <__malloc_lock>
80004350:	20 86       	sub	r6,8
80004352:	e0 6a 01 30 	mov	r10,304
80004356:	6c 18       	ld.w	r8,r6[0x4]
80004358:	74 2e       	ld.w	lr,r10[0x8]
8000435a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000435e:	a1 c8       	cbr	r8,0x0
80004360:	ec 08 00 09 	add	r9,r6,r8
80004364:	72 1b       	ld.w	r11,r9[0x4]
80004366:	e0 1b ff fc 	andl	r11,0xfffc
8000436a:	1c 39       	cp.w	r9,lr
8000436c:	c1 e1       	brne	800043a8 <_free_r+0x68>
8000436e:	f6 08 00 08 	add	r8,r11,r8
80004372:	58 0c       	cp.w	r12,0
80004374:	c0 81       	brne	80004384 <_free_r+0x44>
80004376:	6c 09       	ld.w	r9,r6[0x0]
80004378:	12 16       	sub	r6,r9
8000437a:	12 08       	add	r8,r9
8000437c:	6c 3b       	ld.w	r11,r6[0xc]
8000437e:	6c 29       	ld.w	r9,r6[0x8]
80004380:	97 29       	st.w	r11[0x8],r9
80004382:	93 3b       	st.w	r9[0xc],r11
80004384:	10 99       	mov	r9,r8
80004386:	95 26       	st.w	r10[0x8],r6
80004388:	a1 a9       	sbr	r9,0x0
8000438a:	8d 19       	st.w	r6[0x4],r9
8000438c:	e0 69 05 38 	mov	r9,1336
80004390:	72 09       	ld.w	r9,r9[0x0]
80004392:	12 38       	cp.w	r8,r9
80004394:	c0 63       	brcs	800043a0 <_free_r+0x60>
80004396:	e0 68 07 90 	mov	r8,1936
8000439a:	0e 9c       	mov	r12,r7
8000439c:	70 0b       	ld.w	r11,r8[0x0]
8000439e:	c8 9f       	rcall	800042b0 <_malloc_trim_r>
800043a0:	0e 9c       	mov	r12,r7
800043a2:	fe b0 f3 9d 	rcall	80002adc <__malloc_unlock>
800043a6:	d8 22       	popm	r4-r7,pc
800043a8:	93 1b       	st.w	r9[0x4],r11
800043aa:	58 0c       	cp.w	r12,0
800043ac:	c0 30       	breq	800043b2 <_free_r+0x72>
800043ae:	30 0c       	mov	r12,0
800043b0:	c1 08       	rjmp	800043d0 <_free_r+0x90>
800043b2:	6c 0e       	ld.w	lr,r6[0x0]
800043b4:	f4 c5 ff f8 	sub	r5,r10,-8
800043b8:	1c 16       	sub	r6,lr
800043ba:	1c 08       	add	r8,lr
800043bc:	6c 2e       	ld.w	lr,r6[0x8]
800043be:	0a 3e       	cp.w	lr,r5
800043c0:	f9 bc 00 01 	moveq	r12,1
800043c4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
800043c8:	eb fe 1a 02 	st.wne	r5[0x8],lr
800043cc:	fd f5 1a 03 	st.wne	lr[0xc],r5
800043d0:	f2 0b 00 0e 	add	lr,r9,r11
800043d4:	7c 1e       	ld.w	lr,lr[0x4]
800043d6:	ed be 00 00 	bld	lr,0x0
800043da:	c1 40       	breq	80004402 <_free_r+0xc2>
800043dc:	16 08       	add	r8,r11
800043de:	58 0c       	cp.w	r12,0
800043e0:	c0 d1       	brne	800043fa <_free_r+0xba>
800043e2:	e0 6e 01 30 	mov	lr,304
800043e6:	72 2b       	ld.w	r11,r9[0x8]
800043e8:	2f 8e       	sub	lr,-8
800043ea:	1c 3b       	cp.w	r11,lr
800043ec:	c0 71       	brne	800043fa <_free_r+0xba>
800043ee:	97 36       	st.w	r11[0xc],r6
800043f0:	97 26       	st.w	r11[0x8],r6
800043f2:	8d 2b       	st.w	r6[0x8],r11
800043f4:	8d 3b       	st.w	r6[0xc],r11
800043f6:	30 1c       	mov	r12,1
800043f8:	c0 58       	rjmp	80004402 <_free_r+0xc2>
800043fa:	72 2b       	ld.w	r11,r9[0x8]
800043fc:	72 39       	ld.w	r9,r9[0xc]
800043fe:	93 2b       	st.w	r9[0x8],r11
80004400:	97 39       	st.w	r11[0xc],r9
80004402:	10 99       	mov	r9,r8
80004404:	ec 08 09 08 	st.w	r6[r8],r8
80004408:	a1 a9       	sbr	r9,0x0
8000440a:	8d 19       	st.w	r6[0x4],r9
8000440c:	58 0c       	cp.w	r12,0
8000440e:	c5 a1       	brne	800044c2 <_free_r+0x182>
80004410:	e0 48 01 ff 	cp.w	r8,511
80004414:	e0 8b 00 13 	brhi	8000443a <_free_r+0xfa>
80004418:	a3 98       	lsr	r8,0x3
8000441a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000441e:	72 2b       	ld.w	r11,r9[0x8]
80004420:	8d 39       	st.w	r6[0xc],r9
80004422:	8d 2b       	st.w	r6[0x8],r11
80004424:	97 36       	st.w	r11[0xc],r6
80004426:	93 26       	st.w	r9[0x8],r6
80004428:	a3 48       	asr	r8,0x2
8000442a:	74 19       	ld.w	r9,r10[0x4]
8000442c:	30 1b       	mov	r11,1
8000442e:	f6 08 09 48 	lsl	r8,r11,r8
80004432:	f3 e8 10 08 	or	r8,r9,r8
80004436:	95 18       	st.w	r10[0x4],r8
80004438:	c4 58       	rjmp	800044c2 <_free_r+0x182>
8000443a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000443e:	58 4b       	cp.w	r11,4
80004440:	e0 8b 00 06 	brhi	8000444c <_free_r+0x10c>
80004444:	f0 0b 16 06 	lsr	r11,r8,0x6
80004448:	2c 8b       	sub	r11,-56
8000444a:	c2 08       	rjmp	8000448a <_free_r+0x14a>
8000444c:	59 4b       	cp.w	r11,20
8000444e:	e0 8b 00 04 	brhi	80004456 <_free_r+0x116>
80004452:	2a 5b       	sub	r11,-91
80004454:	c1 b8       	rjmp	8000448a <_free_r+0x14a>
80004456:	e0 4b 00 54 	cp.w	r11,84
8000445a:	e0 8b 00 06 	brhi	80004466 <_free_r+0x126>
8000445e:	f0 0b 16 0c 	lsr	r11,r8,0xc
80004462:	29 2b       	sub	r11,-110
80004464:	c1 38       	rjmp	8000448a <_free_r+0x14a>
80004466:	e0 4b 01 54 	cp.w	r11,340
8000446a:	e0 8b 00 06 	brhi	80004476 <_free_r+0x136>
8000446e:	f0 0b 16 0f 	lsr	r11,r8,0xf
80004472:	28 9b       	sub	r11,-119
80004474:	c0 b8       	rjmp	8000448a <_free_r+0x14a>
80004476:	e0 4b 05 54 	cp.w	r11,1364
8000447a:	e0 88 00 05 	brls	80004484 <_free_r+0x144>
8000447e:	37 eb       	mov	r11,126
80004480:	c0 58       	rjmp	8000448a <_free_r+0x14a>
80004482:	d7 03       	nop
80004484:	f0 0b 16 12 	lsr	r11,r8,0x12
80004488:	28 4b       	sub	r11,-124
8000448a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000448e:	78 29       	ld.w	r9,r12[0x8]
80004490:	18 39       	cp.w	r9,r12
80004492:	c0 e1       	brne	800044ae <_free_r+0x16e>
80004494:	74 18       	ld.w	r8,r10[0x4]
80004496:	a3 4b       	asr	r11,0x2
80004498:	30 1c       	mov	r12,1
8000449a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000449e:	f1 eb 10 0b 	or	r11,r8,r11
800044a2:	12 98       	mov	r8,r9
800044a4:	95 1b       	st.w	r10[0x4],r11
800044a6:	c0 a8       	rjmp	800044ba <_free_r+0x17a>
800044a8:	72 29       	ld.w	r9,r9[0x8]
800044aa:	18 39       	cp.w	r9,r12
800044ac:	c0 60       	breq	800044b8 <_free_r+0x178>
800044ae:	72 1a       	ld.w	r10,r9[0x4]
800044b0:	e0 1a ff fc 	andl	r10,0xfffc
800044b4:	14 38       	cp.w	r8,r10
800044b6:	cf 93       	brcs	800044a8 <_free_r+0x168>
800044b8:	72 38       	ld.w	r8,r9[0xc]
800044ba:	8d 38       	st.w	r6[0xc],r8
800044bc:	8d 29       	st.w	r6[0x8],r9
800044be:	93 36       	st.w	r9[0xc],r6
800044c0:	91 26       	st.w	r8[0x8],r6
800044c2:	0e 9c       	mov	r12,r7
800044c4:	fe b0 f3 0c 	rcall	80002adc <__malloc_unlock>
800044c8:	d8 22       	popm	r4-r7,pc
800044ca:	d7 03       	nop

800044cc <__do_global_ctors_aux>:
800044cc:	d4 21       	pushm	r4-r7,lr
800044ce:	30 c7       	mov	r7,12
800044d0:	c0 28       	rjmp	800044d4 <__do_global_ctors_aux+0x8>
800044d2:	5d 18       	icall	r8
800044d4:	20 47       	sub	r7,4
800044d6:	6e 08       	ld.w	r8,r7[0x0]
800044d8:	5b f8       	cp.w	r8,-1
800044da:	cf c1       	brne	800044d2 <__do_global_ctors_aux+0x6>
800044dc:	d8 22       	popm	r4-r7,pc
800044de:	d7 03       	nop

Disassembly of section .exception:

80004600 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80004600:	c0 08       	rjmp	80004600 <_evba>
	...

80004604 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80004604:	c0 08       	rjmp	80004604 <_handle_TLB_Multiple_Hit>
	...

80004608 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80004608:	c0 08       	rjmp	80004608 <_handle_Bus_Error_Data_Fetch>
	...

8000460c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000460c:	c0 08       	rjmp	8000460c <_handle_Bus_Error_Instruction_Fetch>
	...

80004610 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80004610:	c0 08       	rjmp	80004610 <_handle_NMI>
	...

80004614 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80004614:	c0 08       	rjmp	80004614 <_handle_Instruction_Address>
	...

80004618 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80004618:	c0 08       	rjmp	80004618 <_handle_ITLB_Protection>
	...

8000461c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000461c:	c0 08       	rjmp	8000461c <_handle_Breakpoint>
	...

80004620 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80004620:	c0 08       	rjmp	80004620 <_handle_Illegal_Opcode>
	...

80004624 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80004624:	c0 08       	rjmp	80004624 <_handle_Unimplemented_Instruction>
	...

80004628 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80004628:	c0 08       	rjmp	80004628 <_handle_Privilege_Violation>
	...

8000462c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000462c:	c0 08       	rjmp	8000462c <_handle_Floating_Point>
	...

80004630 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80004630:	c0 08       	rjmp	80004630 <_handle_Coprocessor_Absent>
	...

80004634 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80004634:	c0 08       	rjmp	80004634 <_handle_Data_Address_Read>
	...

80004638 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80004638:	c0 08       	rjmp	80004638 <_handle_Data_Address_Write>
	...

8000463c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000463c:	c0 08       	rjmp	8000463c <_handle_DTLB_Protection_Read>
	...

80004640 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80004640:	c0 08       	rjmp	80004640 <_handle_DTLB_Protection_Write>
	...

80004644 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80004644:	c0 08       	rjmp	80004644 <_handle_DTLB_Modified>
	...

80004650 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80004650:	c0 08       	rjmp	80004650 <_handle_ITLB_Miss>
	...

80004660 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80004660:	c0 08       	rjmp	80004660 <_handle_DTLB_Miss_Read>
	...

80004670 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80004670:	c0 08       	rjmp	80004670 <_handle_DTLB_Miss_Write>
	...

80004700 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80004700:	fe cf 1d 78 	sub	pc,pc,7544

80004704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80004704:	30 0c       	mov	r12,0
80004706:	fe b0 ed 99 	rcall	80002238 <_get_interrupt_handler>
8000470a:	58 0c       	cp.w	r12,0
8000470c:	f8 0f 17 10 	movne	pc,r12
80004710:	d6 03       	rete

80004712 <_int1>:
80004712:	30 1c       	mov	r12,1
80004714:	fe b0 ed 92 	rcall	80002238 <_get_interrupt_handler>
80004718:	58 0c       	cp.w	r12,0
8000471a:	f8 0f 17 10 	movne	pc,r12
8000471e:	d6 03       	rete

80004720 <_int2>:
80004720:	30 2c       	mov	r12,2
80004722:	fe b0 ed 8b 	rcall	80002238 <_get_interrupt_handler>
80004726:	58 0c       	cp.w	r12,0
80004728:	f8 0f 17 10 	movne	pc,r12
8000472c:	d6 03       	rete

8000472e <_int3>:
8000472e:	30 3c       	mov	r12,3
80004730:	fe b0 ed 84 	rcall	80002238 <_get_interrupt_handler>
80004734:	58 0c       	cp.w	r12,0
80004736:	f8 0f 17 10 	movne	pc,r12
8000473a:	d6 03       	rete
8000473c:	d7 03       	nop
8000473e:	d7 03       	nop
80004740:	d7 03       	nop
80004742:	d7 03       	nop
80004744:	d7 03       	nop
80004746:	d7 03       	nop
80004748:	d7 03       	nop
8000474a:	d7 03       	nop
8000474c:	d7 03       	nop
8000474e:	d7 03       	nop
80004750:	d7 03       	nop
80004752:	d7 03       	nop
80004754:	d7 03       	nop
80004756:	d7 03       	nop
80004758:	d7 03       	nop
8000475a:	d7 03       	nop
8000475c:	d7 03       	nop
8000475e:	d7 03       	nop
80004760:	d7 03       	nop
80004762:	d7 03       	nop
80004764:	d7 03       	nop
80004766:	d7 03       	nop
80004768:	d7 03       	nop
8000476a:	d7 03       	nop
8000476c:	d7 03       	nop
8000476e:	d7 03       	nop
80004770:	d7 03       	nop
80004772:	d7 03       	nop
80004774:	d7 03       	nop
80004776:	d7 03       	nop
80004778:	d7 03       	nop
8000477a:	d7 03       	nop
8000477c:	d7 03       	nop
8000477e:	d7 03       	nop
80004780:	d7 03       	nop
80004782:	d7 03       	nop
80004784:	d7 03       	nop
80004786:	d7 03       	nop
80004788:	d7 03       	nop
8000478a:	d7 03       	nop
8000478c:	d7 03       	nop
8000478e:	d7 03       	nop
80004790:	d7 03       	nop
80004792:	d7 03       	nop
80004794:	d7 03       	nop
80004796:	d7 03       	nop
80004798:	d7 03       	nop
8000479a:	d7 03       	nop
8000479c:	d7 03       	nop
8000479e:	d7 03       	nop
800047a0:	d7 03       	nop
800047a2:	d7 03       	nop
800047a4:	d7 03       	nop
800047a6:	d7 03       	nop
800047a8:	d7 03       	nop
800047aa:	d7 03       	nop
800047ac:	d7 03       	nop
800047ae:	d7 03       	nop
800047b0:	d7 03       	nop
800047b2:	d7 03       	nop
800047b4:	d7 03       	nop
800047b6:	d7 03       	nop
800047b8:	d7 03       	nop
800047ba:	d7 03       	nop
800047bc:	d7 03       	nop
800047be:	d7 03       	nop
800047c0:	d7 03       	nop
800047c2:	d7 03       	nop
800047c4:	d7 03       	nop
800047c6:	d7 03       	nop
800047c8:	d7 03       	nop
800047ca:	d7 03       	nop
800047cc:	d7 03       	nop
800047ce:	d7 03       	nop
800047d0:	d7 03       	nop
800047d2:	d7 03       	nop
800047d4:	d7 03       	nop
800047d6:	d7 03       	nop
800047d8:	d7 03       	nop
800047da:	d7 03       	nop
800047dc:	d7 03       	nop
800047de:	d7 03       	nop
800047e0:	d7 03       	nop
800047e2:	d7 03       	nop
800047e4:	d7 03       	nop
800047e6:	d7 03       	nop
800047e8:	d7 03       	nop
800047ea:	d7 03       	nop
800047ec:	d7 03       	nop
800047ee:	d7 03       	nop
800047f0:	d7 03       	nop
800047f2:	d7 03       	nop
800047f4:	d7 03       	nop
800047f6:	d7 03       	nop
800047f8:	d7 03       	nop
800047fa:	d7 03       	nop
800047fc:	d7 03       	nop
800047fe:	d7 03       	nop

Disassembly of section .fini:

80004800 <_fini>:
80004800:	eb cd 40 40 	pushm	r6,lr
80004804:	48 26       	lddpc	r6,8000480c <_fini+0xc>
80004806:	1e 26       	rsub	r6,pc
80004808:	c0 48       	rjmp	80004810 <_fini+0x10>
8000480a:	d7 03       	nop
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	47 ea       	lddsp	r10,sp[0x1f8]
80004810:	fe b0 ec 3c 	rcall	80002088 <__do_global_dtors_aux>
80004814:	e3 cd 80 40 	ldm	sp++,r6,pc
